[
  {
    "objectID": "core/usage.html",
    "href": "core/usage.html",
    "title": "Usage",
    "section": "",
    "text": "Ribasim is typically used as a command-line interface (CLI). It is distributed as a .zip archive, that must be downloaded and unpacked. It can be placed anywhere, however it is important that the contents of the zip file are kept together in a directory. The Ribasim CLI executable is in the bin directory.\nTo download ribasim_cli.zip, see the download section.\nTo check whether the installation was performed successfully, run ribasim with no arguments in the command line. This will give the following message:",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#sec-solver-settings",
    "href": "core/usage.html#sec-solver-settings",
    "title": "Usage",
    "section": "1.1 Solver settings",
    "text": "1.1 Solver settings\nThe solver section in the configuration file is entirely optional, since we aim to use defaults that will generally work well. Common reasons to modify the solver settings are to adjust the calculation or result stepsizes: dt, and saveat. If your model does not converge, or your performance is lower than expected, it can help to adjust other solver settings as well.\nThe default solver algorithm = \"QNDF\", which is a multistep method similar to Matlab’s ode15s (Shampine and Reichelt 1997). It is an implicit method that supports the default adaptive timestepping. The full list of available solvers is: QNDF, Rosenbrock23, TRBDF2, Rodas5, KenCarp4, Tsit5, RK4, ImplicitEuler, Euler. Information on the solver algorithms can be found on the ODE solvers page.\nBy default Ribasim uses adaptive timestepping, though not all algorithms support adaptive timestepping. To use fixed timesteps, provide a timestep size in seconds; dt = 3600.0 corresponds to an hourly timestep. With adaptive timestepping, dtmin and dtmax control the minimum and maximum allowed dt. If a smaller dt than dtmin is needed to meet the set error tolerances, the simulation stops, unless force_dtmin is set to true. force_dtmin is off by default to ensure an accurate solution.\nThe default result stepsize, saveat = 86400 will save results after every day that passed. The calculation and result stepsize need not be the same. If you wish to save every calculation step, set saveat = 0. If you wish to not save any intermediate steps, set saveat = inf.\nThe Jacobian matrix provides information about the local sensitivity of the model with respect to changes in the states. For implicit solvers it must be calculated often, which can be expensive to do. There are several methods to do this. By default Ribasim uses a Jacobian derived automatically using ForwardDiff.jl with memory management provided by PreallocationTools.jl. If this is not used by setting autodiff = false, the Jacobian is calculated with a finite difference method, which can be less accurate and more expensive.\nBy default the Jacobian matrix is a sparse matrix (sparse = true). Since each state typically only depends on a small number of other states, this is generally more efficient, especially for larger models. The sparsity structure is calculated from the network and provided as a Jacobian prototype to the solver. For small or highly connected models it could be faster to use a dense Jacobian matrix instead by setting sparse = false.\nThe total maximum number of iterations maxiters = 1e9, can normally stay as-is unless doing extremely long simulations.\nThe absolute and relative tolerance for adaptive timestepping can be set with abstol and reltol. For more information on these and other solver options, see the DifferentialEquations.jl docs.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#allocation-settings",
    "href": "core/usage.html#allocation-settings",
    "title": "Usage",
    "section": "1.2 Allocation settings",
    "text": "1.2 Allocation settings\nCurrently there are the following allocation settings: - use_allocation: A boolean which says whether allocation should be used or not; - timestep: a float value in seconds which dictates the update interval for allocations.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#results-settings",
    "href": "core/usage.html#results-settings",
    "title": "Usage",
    "section": "1.3 Results settings",
    "text": "1.3 Results settings\nThe following entries can be set in the configuration in the [results] section.\n\n\n\n\n\n\n\n\nentry\ntype\ndescription\n\n\n\n\ncompression\nBool\nWhether to apply compression or not.\n\n\ncompression_level\nInt\nZstandard compression level. Default is 6, higher compresses more.\n\n\nsubgrid\nBool\nCompute and output more detailed water levels.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#logging-settings",
    "href": "core/usage.html#logging-settings",
    "title": "Usage",
    "section": "1.4 Logging settings",
    "text": "1.4 Logging settings\nThe following entries can be set in the configuration in the [logging] section.\n\n\n\n\n\n\n\n\nentry\ntype\ndescription\n\n\n\n\nverbosity\nString\nVerbosity level: debug, info, warn, or error.\n\n\ntiming\nBool\nEnable timings.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#table-requirements",
    "href": "core/usage.html#table-requirements",
    "title": "Usage",
    "section": "2.1 Table requirements",
    "text": "2.1 Table requirements\nBelow we give details per file, in which we describe the schema of the table using a syntax like this:\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\nstorage\nFloat64\n\\(m^3\\)\nnon-negative\n\n\n\nThis means that two columns are required, one named node_id, that contained elements of type Int32, and a column named storage that contains elements of type Float64. The order of the columns does not matter. In some cases there may be restrictions on the values. This is indicated under restriction.\nTables are also allowed to have rows for timestamps that are not part of the simulation, these will be ignored. That makes it easy to prepare data for a larger period, and test models on a shorted period.\nWhen preparing the model for simulation, input validation is performed in the Julia core. The validation rules are described in the validation section.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#custom-metadata",
    "href": "core/usage.html#custom-metadata",
    "title": "Usage",
    "section": "2.2 Custom metadata",
    "text": "2.2 Custom metadata\nIt may be advantageous to add metadata to rows. For example, basin areas might have names and objects such as weirs might have specific identification codes. Additional columns can be freely added to tables. The column names should be prefixed with meta_. They will not be used in computations or validated by the Julia core.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#basin-time",
    "href": "core/usage.html#basin-time",
    "title": "Usage",
    "section": "5.1 Basin / time",
    "text": "5.1 Basin / time\nThis table is the transient form of the Basin table. The only difference is that a time column is added. The table must by sorted by time, and per time it must be sorted by node_id. At the given timestamps the values are set in the simulation, such that the timeseries can be seen as forward filled.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#basin-state",
    "href": "core/usage.html#basin-state",
    "title": "Usage",
    "section": "5.2 Basin / state",
    "text": "5.2 Basin / state\nThe state table aims to capture the full state of the Basin, such that it can be used as an initial condition, potentially the outcome of an earlier simulation. Currently only the Basin node types have state.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\nlevel\nFloat64\n\\(m\\)\n\\(\\ge\\) basin bottom\n\n\n\nEach Basin ID needs to be in the table.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#basin-profile",
    "href": "core/usage.html#basin-profile",
    "title": "Usage",
    "section": "5.3 Basin / profile",
    "text": "5.3 Basin / profile\nThe profile table defines the physical dimensions of the storage reservoir of each basin.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\narea\nFloat64\n\\(m^2\\)\nnon-negative, per node_id: start positive and not decreasing\n\n\nlevel\nFloat64\n\\(m\\)\nper node_id: increasing\n\n\n\nThe level is the level at the basin outlet. All levels are defined in meters above a datum that is the same for the entire model. An example of the first 5 rows of such a table is given below. The first 4 rows define the profile of ID 2. The number of rows can vary per ID, and must be at least 2. Using a very large number of rows may impact performance.\n\n\n\nnode_id\narea\nlevel\n\n\n\n\n2\n1.0\n6.0\n\n\n2\n1000.0\n7.0\n\n\n2\n1000.0\n9.0\n\n\n3\n1.0\n2.2\n\n\n\nWe use the symbol \\(A\\) for area, \\(h\\) for level and \\(S\\) for storage. The profile provides a function \\(A(h)\\) for each basin. Internally this get converted to two functions, \\(A(S)\\) and \\(h(S)\\), by integrating over the function, setting the storage to zero for the bottom of the profile. The minimum area cannot be zero to avoid numerical issues. The maximum area is used to convert the precipitation flux into an inflow.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#basin-area",
    "href": "core/usage.html#basin-area",
    "title": "Usage",
    "section": "5.4 Basin / area",
    "text": "5.4 Basin / area\nThe optional area table is not used during computation, but provides a place to associate areas in the form of polygons to Basins. Using this makes it easier to recognize which water or land surfaces are represented by Basins.\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\nnode_id\nInt32\nsorted\n\n\ngeom\nPolygon or MultiPolygon\n(optional)",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#basin-subgrid",
    "href": "core/usage.html#basin-subgrid",
    "title": "Usage",
    "section": "5.5 Basin / subgrid",
    "text": "5.5 Basin / subgrid\nThe subgrid_level table defines a piecewise linear interpolation from a basin water level to a subgrid element water level. Many subgrid elements may be associated with a single basin, each with distinct interpolation functions. This functionality can be used to translate a single lumped basin level to a more spatially detailed representation (e.g comparable to the output of a hydrodynamic simulation).\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nsubgrid_id\nInt32\n-\nsorted\n\n\nnode_id\nInt32\n-\nconstant per subgrid_id\n\n\nbasin_level\nFloat64\n\\(m\\)\nsorted per subgrid_id\n\n\nsubgrid_level\nFloat64\n\\(m\\)\nsorted per subgrid_id\n\n\n\nThe table below shows example input for two subgrid elements:\n\n\n\nsubgrid_id\nnode_id\nbasin_level\nsubgrid_level\n\n\n\n\n1\n9\n0.0\n0.0\n\n\n1\n9\n1.0\n1.0\n\n\n1\n9\n2.0\n2.0\n\n\n2\n9\n0.0\n0.5\n\n\n2\n9\n1.0\n1.5\n\n\n2\n9\n2.0\n2.5\n\n\n\nBoth subgrid elements use the water level of the basin with node_id 9 to interpolate to their respective water levels. The first element has a one to one connection with the water level; the second also has a one to one connection, but is offset by half a meter. A basin water level of 0.3 would be translated to a water level of 0.3 for the first subgrid element, and 0.8 for the second. Water levels beyond the last basin_level are linearly extrapolated.\nNote that the interpolation to subgrid water level is not constrained by any water balance within Ribasim. Generally, to create physically meaningful subgrid water levels, the subgrid table must be parametrized properly such that the spatially integrated water volume of the subgrid elements agrees with the total storage volume of the basin.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#sec-basin-conc",
    "href": "core/usage.html#sec-basin-conc",
    "title": "Usage",
    "section": "5.6 Basin / concentration",
    "text": "5.6 Basin / concentration\nThis table defines the concentration(s) of (a) substance(s) for the inflow boundaries of a Basin node.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nsubstance\nString\n\ncan correspond to known Delwaq substances\n\n\ndrainage\nFloat64\n\\(g m^{-3}\\)\n(optional)\n\n\nprecipitation\nFloat64\n\\(g m^{-3}\\)\n(optional)",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#sec-basin-conc-state",
    "href": "core/usage.html#sec-basin-conc-state",
    "title": "Usage",
    "section": "5.7 Basin / concentrationstate",
    "text": "5.7 Basin / concentrationstate\nThis table defines the concentration(s) of (a) substance(s) in the basin at the start of the simulation.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nsubstance\nString\n-\ncan correspond to known Delwaq substances\n\n\nconcentration\nFloat64\n\\(g m^{-3}\\)",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#basin-concentrationexternal",
    "href": "core/usage.html#basin-concentrationexternal",
    "title": "Usage",
    "section": "5.8 Basin / concentrationexternal",
    "text": "5.8 Basin / concentrationexternal\nThis table is used for (external) concentrations, that can be used for Control lookups.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nsubstance\nString\n-\ncan correspond to known Delwaq substances\n\n\nconcentration\nFloat64\n\\(g m^{-3}\\)",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#tabulatedratingcurve-time",
    "href": "core/usage.html#tabulatedratingcurve-time",
    "title": "Usage",
    "section": "7.1 TabulatedRatingCurve / time",
    "text": "7.1 TabulatedRatingCurve / time\nThis table is the transient form of the TabulatedRatingCurve table. The only difference is that a time column is added. The table must by sorted by time, and per time it must be sorted by node_id. With this the rating curves can be updated over time. Note that a node_id can be either in this table or in the static one, but not both.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nlevel\nFloat64\n\\(m\\)\nsorted per node_id per time\n\n\nflow_rate\nFloat64\n\\(m^3 s^{-1}\\)\nnon-negative",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#userdemand-time",
    "href": "core/usage.html#userdemand-time",
    "title": "Usage",
    "section": "10.1 UserDemand / time",
    "text": "10.1 UserDemand / time\nThis table is the transient form of the UserDemand table. The only difference is that a time column is added and activity is assumed to be true. The table must by sorted by time, and per time it must be sorted by node_id. With this the demand can be updated over time. In between the given times the demand is interpolated linearly, and outside the demand is constant given by the nearest time value. Note that a node_id can be either in this table or in the static one, but not both.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\npriority\nInt32\n-\npositive, sorted per node id\n\n\ntime\nDateTime\n-\nsorted per priority per node id\n\n\ndemand\nFloat64\n\\(m^3 s^{-1}\\)\nnon-negative\n\n\nreturn_factor\nFloat64\n-\nbetween [0 - 1]\n\n\nmin_level\nFloat64\n\\(m\\)\n-",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#leveldemand-time",
    "href": "core/usage.html#leveldemand-time",
    "title": "Usage",
    "section": "11.1 LevelDemand / time",
    "text": "11.1 LevelDemand / time\nThis table is the transient form of the LevelDemand table, in which time-dependent minimum and maximum levels can be supplied. Similar to the static version, only a single priority per LevelDemand node can be provided.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node id\n\n\nmin_level\nFloat64\n\\(m\\)\n-\n\n\nmax_level\nFloat64\n\\(m\\)\n-\n\n\npriority\nInt32\n-\npositive",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#flowdemand-time",
    "href": "core/usage.html#flowdemand-time",
    "title": "Usage",
    "section": "12.1 FlowDemand / time",
    "text": "12.1 FlowDemand / time\nThis table is the transient form of the FlowDemand table, in which a time-dependent demand can be supplied. Similar to the static version, only a single priority per FlowDemand node can be provided.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node id\n\n\npriority\nInt32\n-\npositive\n\n\ndemand\nFloat64\n\\(m^3 s^{-1}\\)\nnon-negative",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#levelboundary-time",
    "href": "core/usage.html#levelboundary-time",
    "title": "Usage",
    "section": "13.1 LevelBoundary / time",
    "text": "13.1 LevelBoundary / time\nThis table is the transient form of the LevelBoundary table. The only difference is that a time column is added and activity is assumed to be true. The table must by sorted by time, and per time it must be sorted by node_id. With this the levels can be updated over time. In between the given times the level is interpolated linearly, and outside the flow rate is constant given by the nearest time value. Note that a node_id can be either in this table or in the static one, but not both.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nlevel\nFloat64\n\\(m\\)\n-",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#sec-level-boundary-conc",
    "href": "core/usage.html#sec-level-boundary-conc",
    "title": "Usage",
    "section": "13.2 LevelBoundary / concentration",
    "text": "13.2 LevelBoundary / concentration\nThis table defines the concentration(s) of (a) substance(s) for the flow from the LevelBoundary.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nsubstance\nString\n-\ncan correspond to known Delwaq substances\n\n\nconcentration\nFloat64\n\\(g m^{-3}\\)",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#flowboundary-time",
    "href": "core/usage.html#flowboundary-time",
    "title": "Usage",
    "section": "14.1 FlowBoundary / time",
    "text": "14.1 FlowBoundary / time\nThis table is the transient form of the FlowBoundary table. The only differences are that a time column is added and the nodes are assumed to be active so this column is removed. The table must by sorted by time, and per time it must be sorted by node_id. With this the flow rates can be updated over time. In between the given times the flow rate is interpolated linearly, and outside the flow rate is constant given by the nearest time value. Note that a node_id can be either in this table or in the static one, but not both.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nflow_rate\nFloat64\n\\(m^3 s^{-1}\\)\nnon-negative",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#sec-flow-boundary-conc",
    "href": "core/usage.html#sec-flow-boundary-conc",
    "title": "Usage",
    "section": "14.2 FlowBoundary / concentration",
    "text": "14.2 FlowBoundary / concentration\nThis table defines the concentration(s) of (a) substance(s) for the flow from the FlowBoundary.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nsubstance\nString\n-\ncan correspond to known Delwaq substances\n\n\nconcentration\nFloat64\n\\(g m^{-3}\\)",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#discretecontrol-variable",
    "href": "core/usage.html#discretecontrol-variable",
    "title": "Usage",
    "section": "18.1 DiscreteControl / variable",
    "text": "18.1 DiscreteControl / variable\nThe compound variable schema defines linear combinations of variables which can be used in conditions. This means that this schema defines new variables with the given compound_variable_id that look like \\[\n\\text{weight}_1 * \\text{variable}_1 + \\text{weight}_2 * \\text{variable}_2 + \\ldots,\n\\]\nwhich can be for instance an average or a difference of variables. If a variable comes from a time-series, a look ahead \\(\\Delta t\\) can be supplied.\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ncompound_variable_id\nInt32\n-\nsorted per node_id\n\n\nlisten_node_type\nString\n-\nknown node type\n\n\nlisten_node_id\nInt32\n-\nsorted per node_id\n\n\nvariable\nString\n-\nmust be “level” or “flow_rate”, sorted per listen_node_id\n\n\nweight\nFloat64\n-\n(optional, default 1.0)\n\n\nlook_ahead\nFloat64\n\\(s\\)\nOnly on transient boundary conditions, non-negative (optional, default 0.0).",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#discretecontrol-condition",
    "href": "core/usage.html#discretecontrol-condition",
    "title": "Usage",
    "section": "18.2 DiscreteControl / condition",
    "text": "18.2 DiscreteControl / condition\nThe condition schema defines conditions of the form ‘the discrete_control node with this node_idlistens to whether the variable given by the node_id and compound_variable_id is greater than greater_than’. Multiple conditions with different greater_than values can be defined on the same compound_variable.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ncompound_variable_id\nInt32\n-\n-\n\n\ngreater_than\nFloat64\nvarious\nsorted per variable",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#discretecontrol-logic",
    "href": "core/usage.html#discretecontrol-logic",
    "title": "Usage",
    "section": "18.3 DiscreteControl / logic",
    "text": "18.3 DiscreteControl / logic\nThe logic schema defines which control states are triggered based on the truth of the conditions a DiscreteControl node listens to. DiscreteControl is applied in the Julia core as follows:\n\nDuring the simulation it is checked whether the truth of any of the conditions changes.\nWhen a condition changes, the corresponding DiscreteControl node ID is retrieved (node_id in the condition schema above).\nThe truth value of all the conditions this DiscreteControl node listens to are retrieved, in the sorted order as specified in the condition schema. This is then converted into a string of “T” for true and “F” for false. This string we call the truth state.*\nThe table below determines for the given DiscreteControl node ID and truth state what the corresponding control state is.\nFor all the nodes this DiscreteControl node affects (as given by the “control” edges in Edges / static), their parameters are set to those parameters in NodeType / static corresponding to the determined control state.\n\n*. There is also a second truth state created in which for the last condition that changed it is specified whether it was an upcrossing (“U”) or downcrossing (“D”) of the threshold (greater than) value. If a control state is specified for a truth state that is crossing-specific, this takes precedence over the control state for the truth state that contains only “T” and “F”.\n\n\n\n\n\n\nNote\n\n\n\nWhen creating truth states, it is important to not use the order of the condition table as you provide it, but the order as it is written to the file. Users can provide tables in any order, but when writing the model it gets sorted in the required order as specified in the schema.\n\n\n\n\n\n\n\n\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ncontrol_state\nString\n-\n-\n\n\ntruth_state\nString\n-\nConsists of the characters “T” (true), “F” (false), “U” (upcrossing), “D” (downcrossing) and “*” (any), sorted per node_id",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#pidcontrol-time",
    "href": "core/usage.html#pidcontrol-time",
    "title": "Usage",
    "section": "19.1 PidControl / time",
    "text": "19.1 PidControl / time\nThis table is the transient form of the PidControl table. The differences are that a time column is added and the nodes are assumed to be active so this column is removed. The table must by sorted by time, and per time it must be sorted by node_id. With this the target level and PID coefficients can be updated over time. In between the given times the these values interpolated linearly, and outside these values area constant given by the nearest time value. Note that a node_id can be either in this table or in the static one, but not both.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nnode_id\nInt32\n-\nsorted\n\n\ntime\nDateTime\n-\nsorted per node_id\n\n\nlisten_node_type\nInt32\n-\nknown node type\n\n\nlisten_node_id\nInt32\n-\n-\n\n\ntarget\nFloat64\n\\(m\\)\n-\n\n\nproportional\nFloat64\n\\(s^{-1}\\)\n-\n\n\nintegral\nFloat64\n\\(s^{-2}\\)\n-\n\n\nderivative\nFloat64\n-\n-",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#basin---basin.arrow",
    "href": "core/usage.html#basin---basin.arrow",
    "title": "Usage",
    "section": "20.1 Basin - basin.arrow",
    "text": "20.1 Basin - basin.arrow\nThe Basin table contains:\n\nResults of the storage and level of each Basin, which are instantaneous values;\nResults of the fluxes on each Basin, which are mean values over the saveat intervals. In the time column the start of the period is indicated.\nThe initial condition is written to the file, but the final state is not. It will be placed in a separate output state file in the future.\nThe inflow_rate and outflow_rate are the sum of the flows from other nodes into and out of the Basin respectively. The actual flows determine in which term they are counted, not the edge direction.\nThe storage_rate is flow that adds to the storage in the Basin, increasing the water level. In the equations below this number is split out into two non-negative numbers, storage_increase and storage_decrease.\nThe balance_error is the difference of all Basin inflows (total_inflow) and outflows (total_outflow), that is (inflow_rate + precipitation + drainage - storage_increase) - (outflow_rate + evaporation + infiltration - storage_decrease). It can be used to check if the numerical error when solving the water balance is sufficiently small.\nThe relative_error is the fraction of the balance_error over the mean of the total_inflow and total_outflow.\n\n\n\n\ncolumn\ntype\nunit\n\n\n\n\ntime\nDateTime\n-\n\n\nnode_id\nInt32\n-\n\n\nstorage\nFloat64\n\\(m^3\\)\n\n\nlevel\nFloat64\n\\(m\\)\n\n\ninflow_rate\nFloat64\n\\(m^3 s^{-1}\\)\n\n\noutflow_rate\nFloat64\n\\(m^3 s^{-1}\\)\n\n\nstorage_rate\nFloat64\n\\(m^3 s^{-1}\\)\n\n\nprecipitation\nFloat64\n\\(m^3 s^{-1}\\)\n\n\nevaporation\nFloat64\n\\(m^3 s^{-1}\\)\n\n\ndrainage\nFloat64\n\\(m^3 s^{-1}\\)\n\n\ninfiltration\nFloat64\n\\(m^3 s^{-1}\\)\n\n\nbalance_error\nFloat64\n\\(m^3 s^{-1}\\)\n\n\nrelative_error\nFloat64\n-\n\n\n\nThe table is sorted by time, and per time it is sorted by node_id.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#flow---flow.arrow",
    "href": "core/usage.html#flow---flow.arrow",
    "title": "Usage",
    "section": "20.2 Flow - flow.arrow",
    "text": "20.2 Flow - flow.arrow\nThe flow table contains calculated mean flows over the saveat intervals for every flow edge in the model. In the time column the start of the period is indicated.\n\n\n\ncolumn\ntype\nunit\n\n\n\n\ntime\nDateTime\n-\n\n\nedge_id\nInt32\n-\n\n\nfrom_node_type\nString\n-\n\n\nfrom_node_id\nInt32\n-\n\n\nto_node_type\nString\n-\n\n\nto_node_id\nInt32\n-\n\n\nflow_rate\nFloat64\n\\(m^3 s^{-1}\\)\n\n\n\nThe table is sorted by time, and per time the same edge_id order is used, though not sorted. The edge_id value is the same as the fid written to the Edge table, and can be used to directly look up the Edge geometry. Flows from the “from” to the “to” node have a positive sign, and if the flow is reversed it will be negative.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#discretecontrol---control.arrow",
    "href": "core/usage.html#discretecontrol---control.arrow",
    "title": "Usage",
    "section": "20.3 DiscreteControl - control.arrow",
    "text": "20.3 DiscreteControl - control.arrow\nThe control table contains a record of each change of control state: when it happened, which control node was involved, to which control state it changed and based on which truth state.\n\n\n\ncolumn\ntype\n\n\n\n\ntime\nDateTime\n\n\ncontrol_node_id\nInt32\n\n\ntruth_state\nString\n\n\ncontrol_state\nString",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#allocation---allocation.arrow",
    "href": "core/usage.html#allocation---allocation.arrow",
    "title": "Usage",
    "section": "20.4 Allocation - allocation.arrow",
    "text": "20.4 Allocation - allocation.arrow\nThe allocation table contains a record of allocation results: when it happened, for which node, in which allocation network, and what the demand, allocated flow and realized flow were. The realized values at the starting time of the simulation can be ignored.\n\n\n\ncolumn\ntype\n\n\n\n\ntime\nDateTime\n\n\nsubnetwork_id\nInt32\n\n\nnode_type\nString\n\n\nnode_id\nInt32\n\n\npriority\nInt32\n\n\ndemand\nFloat64\n\n\nallocated\nFloat64\n\n\nrealized\nFloat64\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe LevelDemand node allocations are listed as node type Basin. This is because one LevelDemand node can link to multiple Basins, and doesn’t receive flow by itself.\n\n\nFor Basins the values demand, allocated and realized are positive if the Basin level is below the minimum level given by a LevelDemand node. The values are negative if the Basin supplies due to a surplus of water.\n\n\n\n\n\n\nNote\n\n\n\nCurrently the stored demand and abstraction rate are those at the allocation timepoint (and the abstraction rate is based on the previous allocation optimization). In the future these will be an average over the previous allocation timestep.",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/usage.html#allocation-flow---allocation_flow.arrow",
    "href": "core/usage.html#allocation-flow---allocation_flow.arrow",
    "title": "Usage",
    "section": "20.5 Allocation flow - allocation_flow.arrow",
    "text": "20.5 Allocation flow - allocation_flow.arrow\nThe allocation flow table contains results of the optimized allocation flow on every edge in the model that is part of a subnetwork, for each time an optimization problem is solved (see also here). If in the model a main network and subnetwork(s) are specified, there are 2 different types of optimization for the subnetwork: collecting its total demand per priority (for allocating flow from the main network to the subnetwork), and allocating flow within the subnetwork. The column collect_demands provides the distinction between these two optimization types.\n\n\n\ncolumn\ntype\n\n\n\n\ntime\nDateTime\n\n\nedge_id\nInt32\n\n\nfrom_node_type\nString\n\n\nfrom_node_id\nInt32\n\n\nto_node_type\nString\n\n\nto_node_id\nInt32\n\n\nsubnetwork_id\nInt32\n\n\npriority\nInt32\n\n\nflow_rate\nFloat64\n\n\ncollect_demands\nBool",
    "crumbs": [
      "Julia core",
      "Usage"
    ]
  },
  {
    "objectID": "core/validation.html",
    "href": "core/validation.html",
    "title": "Validation",
    "section": "",
    "text": "The tables below show the validation rules applied to the input to the Julia core before running the model.\n\n1 Connectivity\nIn the table below, each column shows which node types are allowed to be downstream (or ‘down-control’) of the node type at the top of the column.\n\n\nCode\nusing Ribasim\nusing DataFrames: DataFrame\nusing MarkdownTables\n\nnode_names_snake_case = Vector{Symbol}()\nnode_names_camel_case = Vector{Symbol}()\nfor (node_name, node_type) in zip(fieldnames(Ribasim.Parameters), fieldtypes(Ribasim.Parameters))\n    if node_type &lt;: Ribasim.AbstractParameterNode\n        push!(node_names_snake_case, node_name)\n        push!(node_names_camel_case, nameof(node_type))\n    end\nend\n\nfunction to_symbol(b::Bool)::String\n    return b ? \"✓\" : \"x\"\nend\n\n\ndf = DataFrame()\ndf[!, :downstream] = node_names_snake_case\n\nfor node_name in node_names_snake_case\n    df[!, node_name] =\n        [(to_symbol(node_name_ in Ribasim.neighbortypes(node_name))) for node_name_ in node_names_snake_case]\nend\n\nmarkdown_table(df)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndownstream\nbasin\nlinear_resistance\nmanning_resistance\ntabulated_rating_curve\nfractional_flow\nlevel_boundary\nflow_boundary\npump\noutlet\nterminal\ndiscrete_control\npid_control\nuser_demand\nlevel_demand\nflow_demand\n\n\n\n\nbasin\nx\n✓\n✓\n✓\n✓\nx\n✓\n✓\n✓\nx\nx\nx\n✓\n✓\nx\n\n\nlinear_resistance\n✓\nx\nx\nx\nx\n✓\nx\nx\nx\nx\n✓\nx\nx\nx\n✓\n\n\nmanning_resistance\n✓\nx\nx\nx\nx\nx\nx\nx\nx\nx\n✓\nx\nx\nx\n✓\n\n\ntabulated_rating_curve\n✓\nx\nx\nx\nx\n✓\nx\nx\nx\nx\n✓\nx\nx\nx\n✓\n\n\nfractional_flow\nx\nx\nx\n✓\nx\nx\n✓\n✓\n✓\nx\n✓\nx\n✓\nx\nx\n\n\nlevel_boundary\nx\n✓\nx\n✓\n✓\nx\n✓\n✓\n✓\nx\nx\nx\n✓\nx\nx\n\n\nflow_boundary\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n\n\npump\n✓\nx\nx\nx\nx\n✓\nx\nx\nx\nx\n✓\n✓\nx\nx\n✓\n\n\noutlet\n✓\nx\nx\nx\nx\n✓\nx\nx\nx\nx\n✓\n✓\nx\nx\n✓\n\n\nterminal\nx\nx\nx\n✓\n✓\nx\n✓\n✓\n✓\nx\nx\nx\n✓\nx\nx\n\n\ndiscrete_control\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n\n\npid_control\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n✓\nx\nx\nx\nx\n\n\nuser_demand\n✓\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n\n\nlevel_demand\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n\n\nflow_demand\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n\n\n\n\n\n\n\n2 Neighbor amounts\nThe table below shows for each node type between which bounds the amount of in- and outneighbors must be, for both flow and control edges.\n\n\nCode\nflow_in_min = Vector{String}()\nflow_in_max = Vector{String}()\nflow_out_min = Vector{String}()\nflow_out_max = Vector{String}()\ncontrol_in_min = Vector{String}()\ncontrol_in_max = Vector{String}()\ncontrol_out_min = Vector{String}()\ncontrol_out_max = Vector{String}()\n\nfunction unbounded(i::Int)::String\n    return i == typemax(Int) ? \"∞\" : string(i)\nend\n\nfor node_name in node_names_camel_case\n    bounds_flow = Ribasim.n_neighbor_bounds_flow(node_name)\n    push!(flow_in_min, string(bounds_flow.in_min))\n    push!(flow_in_max, unbounded(bounds_flow.in_max))\n    push!(flow_out_min, string(bounds_flow.out_min))\n    push!(flow_out_max, unbounded(bounds_flow.out_max))\n\n    bounds_control = Ribasim.n_neighbor_bounds_control(node_name)\n    push!(control_in_min, string(bounds_control.in_min))\n    push!(control_in_max, unbounded(bounds_control.in_max))\n    push!(control_out_min, string(bounds_control.out_min))\n    push!(control_out_max, unbounded(bounds_control.out_max))\n\nend\n\ndf = DataFrame(\n    ;\n    node_type = node_names_snake_case,\n    flow_in_min,\n    flow_in_max,\n    flow_out_min,\n    flow_out_max,\n    control_in_min,\n    control_in_max,\n    control_out_min,\n    control_out_max,\n)\n\nmarkdown_table(df)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnode_type\nflow_in_min\nflow_in_max\nflow_out_min\nflow_out_max\ncontrol_in_min\ncontrol_in_max\ncontrol_out_min\ncontrol_out_max\n\n\n\n\nbasin\n0\n∞\n0\n∞\n0\n1\n0\n0\n\n\nlinear_resistance\n1\n1\n1\n1\n0\n1\n0\n0\n\n\nmanning_resistance\n1\n1\n1\n1\n0\n1\n0\n0\n\n\ntabulated_rating_curve\n1\n1\n1\n∞\n0\n1\n0\n0\n\n\nfractional_flow\n1\n1\n1\n1\n0\n1\n0\n0\n\n\nlevel_boundary\n0\n∞\n0\n∞\n0\n0\n0\n0\n\n\nflow_boundary\n0\n0\n1\n∞\n0\n0\n0\n0\n\n\npump\n1\n1\n1\n∞\n0\n1\n0\n0\n\n\noutlet\n1\n1\n1\n∞\n0\n1\n0\n0\n\n\nterminal\n1\n∞\n0\n0\n0\n0\n0\n0\n\n\ndiscrete_control\n0\n0\n0\n0\n0\n0\n1\n∞\n\n\npid_control\n0\n0\n0\n0\n0\n1\n1\n1\n\n\nuser_demand\n1\n1\n1\n1\n0\n0\n0\n0\n\n\nlevel_demand\n0\n0\n0\n0\n0\n0\n1\n∞\n\n\nflow_demand\n0\n0\n0\n0\n0\n0\n1\n1",
    "crumbs": [
      "Julia core",
      "Validation"
    ]
  },
  {
    "objectID": "core/coupling.html",
    "href": "core/coupling.html",
    "title": "Coupling",
    "section": "",
    "text": "Ribasim can also be (online) coupled to other kernels with the help of iMOD Coupler. The corresponding documentation can be found within the iMOD Suite Documentation.\n\n\n\nRibasim can be offline coupled to Delwaq, the Deltares Water Quality model. Note that this functionality is still in active development.\n\n\n\n\n\nflowchart LR\n    Ribasim --&gt; Delwaq\n\n\n\n\n\n\n\n\nDelwaq can calculate the concentration of substances in Ribasim Basin nodes over time, based on initial concentrations in basins, and of boundary flows. Ribasim exposes the Basin / concentration, Basin / concentrationstate, FlowBoundary / concentration, and LevelBoundary / concentration tables to setup these substances and concentrations.\nWhen a Ribasim model has been run with the above tables, one can use the utilities in the coupling/delwaq folder to generate the input required for Delwaq to run, as well as to parse the output from Delwaq into a Ribasim compatible format. For more information see the README.md in the same folder.",
    "crumbs": [
      "Julia core",
      "Coupling"
    ]
  },
  {
    "objectID": "core/coupling.html#imod",
    "href": "core/coupling.html#imod",
    "title": "Coupling",
    "section": "",
    "text": "Ribasim can also be (online) coupled to other kernels with the help of iMOD Coupler. The corresponding documentation can be found within the iMOD Suite Documentation.",
    "crumbs": [
      "Julia core",
      "Coupling"
    ]
  },
  {
    "objectID": "core/coupling.html#water-quality",
    "href": "core/coupling.html#water-quality",
    "title": "Coupling",
    "section": "",
    "text": "Ribasim can be offline coupled to Delwaq, the Deltares Water Quality model. Note that this functionality is still in active development.\n\n\n\n\n\nflowchart LR\n    Ribasim --&gt; Delwaq\n\n\n\n\n\n\n\n\nDelwaq can calculate the concentration of substances in Ribasim Basin nodes over time, based on initial concentrations in basins, and of boundary flows. Ribasim exposes the Basin / concentration, Basin / concentrationstate, FlowBoundary / concentration, and LevelBoundary / concentration tables to setup these substances and concentrations.\nWhen a Ribasim model has been run with the above tables, one can use the utilities in the coupling/delwaq folder to generate the input required for Delwaq to run, as well as to parse the output from Delwaq into a Ribasim compatible format. For more information see the README.md in the same folder.",
    "crumbs": [
      "Julia core",
      "Coupling"
    ]
  },
  {
    "objectID": "core/equations.html",
    "href": "core/equations.html",
    "title": "Equations",
    "section": "",
    "text": "Ribasim currently simulates the following “natural” water balance terms:\nAdditionally, Ribasim simulates the following “allocated” water balance terms:\nDepending on the type of boundary conditions, Ribasim requires relation between storage volume and wetted area \\(A\\), and between the storage volume and the water level \\(h\\). These are (currently) represented by piecewise linear relationships.",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#the-jacobian",
    "href": "core/equations.html#the-jacobian",
    "title": "Equations",
    "section": "1.1 The Jacobian",
    "text": "1.1 The Jacobian\nThe Jacobian is a \\(n\\times n\\) matrix where \\(n\\) is the number of states in the simulation. The Jacobian is computed either using finite difference methods or automatic differentiation. For more details on the computation of the Jacobian and how it is used in the solvers see numerical considerations.\nThe entries of the Jacobian \\(J\\) are given by \\[\nJ[i,j] = \\frac{\\partial f_j}{\\partial u_i},\n\\]\nhence \\(J[i,j]\\) quantifies how \\(f_j\\), the derivative of state \\(j\\) with respect to time, changes with a change in state \\(i\\). If a node creates dependendies between basin storages (or other states), then this yields contributions to the Jacobian. If \\(j\\) corresponds to a storage state, then\n\\[\nJ[i,j] = \\sum_{(i',j') \\in E | j' = i} \\frac{\\partial Q_{i',j'}}{\\partial u_i} - \\sum_{(i',j') \\in E | i' = i} \\frac{\\partial Q_{i',j'}}{\\partial u_i},\n\\]\nMost of these terms are always \\(0\\), because a flow over an edge only depends on a small number of states. Therefore the matrix \\(J\\) is very sparse.\nFor many contributions to the Jacobian the derivative of the level \\(l(u)\\) of a basin with respect to its storage \\(u\\) is required. To get an expression for this, we first look at the storage as a function of the level:\n\\[\nu(l) = \\int_{l_0}^l A(\\ell)d\\ell.\n\\]\nFrom this we obtain \\(u'(l) = A(l)\\) and thus \\[\n\\frac{\\text{d}l}{\\text{d}u} = \\frac{1}{A(u)}.\n\\]\n\n\n\n\n\n\nNote\n\n\n\nThe presence of division by the basin area means that areas of size zero are not allowed.",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#sec-reduction_factor",
    "href": "core/equations.html#sec-reduction_factor",
    "title": "Equations",
    "section": "2.1 The reduction factor",
    "text": "2.1 The reduction factor\nAt several points in the equations below a reduction factor is used. This is a term that makes certain transitions more smooth, for instance when a pump stops providing water when its source basin dries up. The reduction factor is given by\n\\[\\begin{align}\n    \\phi(x; p) =\n    \\begin{cases}\n    0 &\\text{if}\\quad x &lt; 0 \\\\\n        -2 \\left(\\frac{x}{p}\\right)^3 + 3\\left(\\frac{x}{p}\\right)^2 &\\text{if}\\quad 0 \\le x \\le p \\\\\n        1 &\\text{if}\\quad x &gt; p\n    \\end{cases}\n\\end{align}\\]\nHere \\(p &gt; 0\\) is the threshold value which determines the interval \\([0,p]\\) of the smooth transition between \\(0\\) and \\(1\\), see the plot below.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef f(x, p = 3):\n    x_scaled = x / p\n    phi = (-2 * x_scaled + 3) * x_scaled**2\n    phi = np.where(x &lt; 0, 0, phi)\n    phi = np.where(x &gt; p, 1, phi)\n\n    return phi\n\nfontsize = 15\np = 3\nN = 100\nx_min = -1\nx_max = 4\nx = np.linspace(x_min,x_max,N)\nphi = f(x,p)\n\nfig,ax = plt.subplots(dpi=80)\nax.plot(x,phi)\n\ny_lim = ax.get_ylim()\n\nax.set_xticks([0,p], [0,\"$p$\"], fontsize=fontsize)\nax.set_yticks([0,1], [0,1], fontsize=fontsize)\nax.hlines([0,1],x_min,x_max, color = \"k\", ls = \":\", zorder=-1)\nax.vlines([0,p], *y_lim, color = \"k\", ls = \":\")\nax.set_xlim(x_min,x_max)\nax.set_xlabel(\"$x$\", fontsize=fontsize)\nax.set_ylabel(r\"$\\phi(x;p)$\", fontsize=fontsize)\nax.set_ylim(y_lim)\n\nfig.tight_layout()\nplt.show()",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#precipitation",
    "href": "core/equations.html#precipitation",
    "title": "Equations",
    "section": "2.2 Precipitation",
    "text": "2.2 Precipitation\nThe precipitation term is given by\n\\[\n    Q_P = P \\cdot A.\n\\tag{2}\\]\nHere \\(P = P(t)\\) is the precipitation rate and \\(A\\) is the maximum area given in the Basin / profile table. Precipitation in the Basin area is assumed to be directly added to the Basin storage. The modeler needs to ensure all precipitation enters the model, and there is no overlap in the maximum profile areas, else extra water is created. If a part of the catchment is not in any Basin profile, the modeler has to verify that water source is not forgotten. It can for instance be converted to a flow rate and added to a Basin as a FlowBoundary.",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#evaporation",
    "href": "core/equations.html#evaporation",
    "title": "Equations",
    "section": "2.3 Evaporation",
    "text": "2.3 Evaporation\nThe evaporation term is given by\n\\[\n    Q_E = E_\\text{pot} \\cdot A(u) \\cdot \\phi(d;0.1).\n\\tag{3}\\]\nHere \\(E_\\text{pot} = E_\\text{pot}(t)\\) is the potential evaporation rate and \\(A\\) is the wetted area. \\(\\phi\\) is the reduction factor which depends on the depth \\(d\\). It provides a smooth gradient as \\(u \\rightarrow 0\\).\nA straightforward formulation \\(Q_E = \\mathrm{max}(E_\\text{pot} A(u),\n0)\\) is unsuitable, as \\(\\frac{\\mathrm{d}Q_E}{\\mathrm{d}u}(u=0)\\) is then not well-defined.\n\nA non-smooth derivative results in extremely small timesteps and long computation time: ModelingToolkit identifies the singular behavior and adjusts its timestepping. In a physical interpretation, evaporation is switched on or off per individual droplet of water. In general, the effect of the reduction term is negligible, or not even necessary. As a surface water dries, its wetted area decreases and so does the evaporative flux. However, for (simplified) cases with constant wetted surface (a rectangular profile), evaporation only stops at \\(u =\n0\\).",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#infiltration-and-drainage",
    "href": "core/equations.html#infiltration-and-drainage",
    "title": "Equations",
    "section": "2.4 Infiltration and Drainage",
    "text": "2.4 Infiltration and Drainage\nInfiltration is provided as a lump sum for the basin. If Ribasim is coupled with MODFLOW 6, the infiltration is computed as the sum of all positive flows of the MODFLOW 6 boundary conditions in the basin:\n\\[\n    Q_\\text{inf} = \\sum_{i=1}^{n} \\sum_{j=1}^{m} \\max(Q_{\\mathrm{mf6}_{i,j}}, 0.0)\n\\tag{4}\\]\nWhere \\(i\\) is the index of the boundary condition, \\(j\\) the MODFLOW 6 cell index, \\(n\\) the number of boundary conditions, and \\(m\\) the number of MODFLOW 6 cells in the basin. \\(Q_{\\mathrm{mf6}_{i,j}}\\) is the flow computed by MODFLOW 6 for cell \\(j\\) for boundary condition \\(i\\).\nDrainage is a lump sump for the basin, and consists of the sum of the absolute value of all negative flows of the MODFLOW 6 boundary conditions in the basin.\n\\[\n    Q_\\text{drn} = \\sum_{i=1}^{n} \\sum_{j=1}^{m} \\left| \\min(Q_{\\mathrm{mf6}_{i,j}}, 0.0) \\right|\n\\tag{5}\\]\nThe interaction with MODFLOW 6 boundary conditions is explained in greater detail in the the iMOD Coupler docs.",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#upstream-and-downstream-flow",
    "href": "core/equations.html#upstream-and-downstream-flow",
    "title": "Equations",
    "section": "2.5 Upstream and downstream flow",
    "text": "2.5 Upstream and downstream flow\nRibasim’s basins can be connected to each other, and each basin expects an explicit connection. These connections are currently available for inter-basin flows:\n\n\nPump\nTabulatedRatingCurve\nLinearResistance\nManningResistance\n\nThe flow direction of the basin is not pre-determined: flow directions may freely reverse, provided the connection allows it. Currently, a LinearResistance allows bidirectional flow, but the\nAdditionally, three additional “connections” area available for the “outmost” basins (external nodes) in a network.\n\nTerminal\nLevelBoundary\nFlowBoundary\n\n\n2.5.1 Pump\nThe behaviour of pumps is very straight forward if these nodes are not PID controlled. Their flow is given by a fixed flow rate \\(q\\), multiplied by a reduction factor: \\[\nQ_\\text{pump} = \\phi(u; 10.0)q\n\\]\nHere \\(u\\) is the storage of the upstream basin. The reduction factor \\(\\phi\\) makes sure that the flow of the pump goes smootly to \\(0\\) as the upstream basin dries out.\n\n\n2.5.2 Outlet\nThe outlet is very similar to the pump, but it has a few extra reduction factors for physical constraints: \\[\nQ_\\text{outlet} = \\phi(u_a; 10.0)\\phi(\\Delta h; 0.1) \\phi(h_a-h_\\text{min};0.1)q.\n\\] The subscript \\(a\\) denotes the upstream node and \\(b\\) the downstream node. The first reduction factor is equivalent to the one for the pump. The second one makes sure that the outlet flow goes to zero as the head difference \\(\\Delta h = h_a - h_b\\) goes to zero. The last one makes sure that the outlet only produces flow when the upstream level is above the minimum chrest level \\(h_\\text{min}\\).\nNot all node types upstream or downstream of the outlet have a defined level. If this is the case, and therefore the reduction factor cannot be computed, it is defined to be \\(1.0\\).\n\n\n2.5.3 TabulatedRatingCurve\nThe Tabulated Rating Curve is a tabulation of a basin’s discharge behavior. It describes a piecewise linear relationship between the basin’s level and its discharge. It can be understood as an empirical description of a basin’s properties. This can include an outlet, but also the lumped hydraulic behavior of the upstream channels.\n\n\n\n\n\n\nNote\n\n\n\nCurrently, the discharge relies only on the basin’s level; it could also use the volume of both connected basins to simulate backwater effects, submersion of outlets, or even reversal of flows for high precipitation events.\n\n\n\n\n2.5.4 LinearResistance\nA LinearResistance connects two basins together. The flow between the two basins is determined by a linear relationship, up to an optional maximum flow rate:\n\\[\n    Q = \\mathrm{clamp}(\\frac{h_a - h_b}{R}, -Q_{\\max}, Q_{\\max})\n\\tag{6}\\]\nHere \\(h_a\\) is the water level in the first basin and \\(h_b\\) is the water level in the second basin. \\(R\\) is the resistance of the link, and \\(Q_{\\max}\\) is the maximum flow rate. A LinearResistance makes no assumptions about the direction of the flow: water flows from high to low.\n\n\n2.5.5 Terminal\nThis only allows outflow from a basin into a terminal node.\n\n\n2.5.6 LevelBoundary\nThis can be connected to a basin via a LinearResistance. This boundary node will then exchange water with the basin based on the difference in water level between the two.\n\n\n2.5.7 FlowBoundary\nThis can be connected directly to a basin and prescribes the flow to or from that basin. We require that the edge connecting the flow boundary to the basin should point towards the basin, so that positive flow corresponds to water being added to the model.\n\n\n2.5.8 Manning connection\nRibasim is capable of simulating steady flow between basins through a reach described by a trapezoidal profile and a Manning roughness coefficient.\nWe describe the discharge from basin \\(a\\) to basin \\(b\\) solely as a function of the water levels in \\(a\\) and \\(b\\).\n\\[\nQ = f(h_a, h_b)\n\\]\nwhere:\n\nThe subscripts \\(a,b\\) denote basins\n\\(h\\) is the hydraulic head, or water level\n\nThe energy equation for open channel flow is:\n\\[\nH = h + \\frac{v^2}{2g}\n\\]\nWhere\n\n\\(H\\) is total head\n\\(v\\) is average water velocity\n\\(g\\) is gravitational acceleration\n\nThe discharge \\(Q\\) is defined as:\n\\[\nQ = Av\n\\]\nwhere \\(A\\) is cross-sectional area.\nWe use conservation of energy to relate the total head at \\(a\\) to \\(b\\), with \\(H_a &gt; H_b\\) as follows:\n\\[\nH_a = H_b + h_{\\text{loss}}\n\\]\nOr:\n\\[\nh_a + \\frac{v_a^2}{2g} = h_b + \\frac{v_b^2}{2g} + h_{\\text{loss}}\n\\]\nWhere \\(v\\) is the average water velocity. \\(h_{\\text{loss}}\\) is a combination of friction and contraction/expansion losses:\n\\[\nh_{\\text{loss}} = S_f L + \\frac{C}{2g} \\left(v_b^2 - v_a^2\\right)\n\\]\nWhere:\n\n\\(L\\) is the reach length\n\\(S_f\\) is the representative friction slope\n\\(C\\) is the expansion or contraction coefficient, \\(0 \\le C \\le1\\)\n\nWe assume velocity differences in a connection are negligible (\\(v_a = v_b\\)):\n\\[\nh_a = h_b + S_f L\n\\]\nFriction losses are computed with the Gauckler-Manning formula:\n\\[\nQ = \\frac{A}{n} R_h^\\frac{2}{3} \\sqrt{S_f}\n\\]\nWhere:\n\n\\(A\\) is the representative area.\n\\(R_h\\) is the representative wetted radius.\n\\(S_f\\) is the representative friction slope.\n\\(n\\) is Manning’s roughness coefficient.\n\nWe can rewrite to express \\(S_f\\) in terms of Q:\n\\[\nS_f = Q^2 \\frac{n^2}{A^2 R_h^{4/3}}\n\\]\nNo water is added or removed in a connection:\n\\[\nQ_a = Q_b = Q\n\\]\nSubstituting:\n\\[\nh_a = h_b + Q^2 \\frac{n^2}{A^2 R_h^{4/3}} L\n\\]\nWe can then express \\(Q\\) as a function of head difference \\(\\Delta h\\):\n\\[\nQ = \\textrm{sign}(\\Delta h) \\frac{A}{n} R_h^{2/3}\\sqrt{\\frac{|\\Delta h|}{L} }\n\\]\nThe \\(\\textrm{sign}(\\Delta h)\\) term causes the direction of the flow to reverse if the head in basin \\(b\\) is larger than in basin \\(a\\).\nThis expression however leads to problems in simulation since the derivative of \\(Q\\) with respect to \\(\\Delta h\\) tends to \\(\\pm \\infty\\) as \\(\\Delta h\\) tends to 0. Therefore we use the slightly modified expression\n\\[\nQ = \\textrm{sign}(\\Delta h) \\frac{A}{n} R_h^{2/3}\\sqrt{\\frac{\\Delta h}{L} s(\\Delta h)}\n\\]\nto smooth out this problem. Here \\(s(x) = \\frac{2}{\\pi}\\arctan{1000x}\\) can be thought of as a smooth approximation of the sign function.\n\n\n\n\n\n\nNote\n\n\n\nThe computation of \\(S_f\\) is not exact: we base it on a representative area and hydraulic radius, rather than integrating \\(S_f\\) along the length of a reach. Direct analytic solutions exist for e.g. parabolic profiles (Tolkmitt), but other profiles requires relatively complicated approaches (such as approximating the profile with a polynomial).\nWe use the average value of the cross-sectional area, the average value of the water depth, and the average value of the hydraulic radius to compute a friction slope. The size of the resulting error will depend on the water depth difference between the upstream and downstream basin.\n\n\nThe cross sectional area for a trapezoidal or rectangular profile:\n\\[\nA = w d + \\frac{\\Delta y}{\\Delta z} d^2\n\\]\nWhere\n\n\\(w\\) is the width at \\(d = 0\\) (A triangular profile has \\(w = 0\\))\n\\(\\frac{\\Delta y}{\\Delta z}\\) is the slope of the profile expressed as the horizontal length for one unit in the vertical (A slope of 45 degrees has \\(\\frac{\\Delta y}{\\Delta z} = 1\\); a rectangular profile 0).\n\nAccordingly, the wetted perimeter is:\n\\[\nB = w + 2 d \\sqrt{\\left(\\frac{\\Delta y}{\\Delta z}\\right)^2 + 1}\n\\]",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#the-derivative-term",
    "href": "core/equations.html#the-derivative-term",
    "title": "Equations",
    "section": "4.1 The derivative term",
    "text": "4.1 The derivative term\nWhen \\(K_d \\ne 0\\) this adds a level of complexity. We can see this by looking at the error derivative more closely: \\[\n\\frac{\\text{d}e}{\\text{d}t} = \\frac{\\text{d}\\text{SP}}{\\text{d}t} - \\frac{1}{A(u_\\text{PID})}\\frac{\\text{d}u_\\text{PID}}{\\text{d}t},\n\\] where \\(A(u_\\text{PID})\\) is the area of the controlled basin as a function of the storage of the controlled basin \\(u_\\text{PID}\\). The complexity arises from the fact that \\(Q_\\text{PID}\\) is a contribution to \\(\\frac{\\text{d}u_\\text{PID}}{\\text{d}t} = f_\\text{PID}\\), which makes Equation 8 an implicit equation for \\(Q_\\text{PID}\\). We define\n\\[\nf_\\text{PID} = \\hat{f}_\\text{PID} \\pm Q_\\text{pump/outlet},\n\\]\nthat is, \\(\\hat{f}_\\text{PID}\\) is the right hand side of the ODE for the controlled basin storage state without the contribution of the PID controlled pump. The plus sign holds for an outlet and the minus sign for a pump, dictated by the way the pump and outlet connectivity to the controlled basin is enforced.\nUsing this, solving Equation 8 for \\(Q_\\text{PID}\\) yields \\[\nQ_\\text{pump/outlet} = \\text{clip}\\left(\\phi(u_\\text{us})\\frac{K_pe + K_iI + K_d \\left(\\frac{\\text{d}\\text{SP}}{\\text{d}t}-\\frac{\\hat{f}_\\text{PID}}{A(u_\\text{PID})}\\right)}{1\\pm\\phi(u_\\text{us})\\frac{K_d}{A(u_\\text{PID})}};Q_{\\min},Q_{\\max}\\right),\n\\] where the clipping is again done last. Note that to compute this, \\(\\hat{f}_\\text{PID}\\) has to be known first, meaning that the PID controlled pump/outlet flow rate has to be computed after all other contributions to the PID controlled basin’s storage are known.",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "core/equations.html#the-sign-of-the-parameters",
    "href": "core/equations.html#the-sign-of-the-parameters",
    "title": "Equations",
    "section": "4.2 The sign of the parameters",
    "text": "4.2 The sign of the parameters\nNote by Equation 7 that the error is positive if the setpoint is larger than the basin level and negative if the setpoint is smaller than the basin level.\nWe enforce the convention that when a pump is controlled, its edge points away from the basin, and when an outlet is controlled, its edge points towards the basin, so that the main flow direction along these edges is positive. Therefore, positive flows of the pump and outlet have opposite effects on the basin, and thus the parameters \\(K_p,K_i,K_d\\) of the pump and outlet must have oppositive signs to achieve the same goal.",
    "crumbs": [
      "Julia core",
      "Equations"
    ]
  },
  {
    "objectID": "python/index.html",
    "href": "python/index.html",
    "title": "Python tooling",
    "section": "",
    "text": "The Ribasim Python package (named ribasim) aims to make it easy to build, update and analyze Ribasim models programmatically.\nThe Ribasim QGIS plugin allows users to construct a model from scratch without programming. For specific tasks, like adding observed rainfall timeseries, it can be faster to use Python instead.\nOne can also use Ribasim Python to build entire models from base data, such that your model setup is fully reproducible.\nThe package is registered in PyPI and can therefore be installed with pip:\npip install ribasim\nFor wheel (.whl) downloads, including nightly builds, see the download section. After downloading wheels can be installed by referring to the correct path:\npip install path/to/ribasim-*.whl\nFor documentation please see the examples and API reference.",
    "crumbs": [
      "Python tooling"
    ]
  },
  {
    "objectID": "python/reference/nodes.flow_boundary.html",
    "href": "python/reference/nodes.flow_boundary.html",
    "title": "1 nodes.flow_boundary",
    "section": "",
    "text": "1 nodes.flow_boundary\nnodes.flow_boundary"
  },
  {
    "objectID": "python/reference/nodes.fractional_flow.html",
    "href": "python/reference/nodes.fractional_flow.html",
    "title": "1 nodes.fractional_flow",
    "section": "",
    "text": "1 nodes.fractional_flow\nnodes.fractional_flow"
  },
  {
    "objectID": "python/reference/nodes.basin.html",
    "href": "python/reference/nodes.basin.html",
    "title": "1 nodes.basin",
    "section": "",
    "text": "1 nodes.basin\nnodes.basin"
  },
  {
    "objectID": "python/reference/nodes.pid_control.html",
    "href": "python/reference/nodes.pid_control.html",
    "title": "1 nodes.pid_control",
    "section": "",
    "text": "1 nodes.pid_control\nnodes.pid_control"
  },
  {
    "objectID": "python/reference/nodes.tabulated_rating_curve.html",
    "href": "python/reference/nodes.tabulated_rating_curve.html",
    "title": "1 nodes.tabulated_rating_curve",
    "section": "",
    "text": "1 nodes.tabulated_rating_curve\nnodes.tabulated_rating_curve"
  },
  {
    "objectID": "python/reference/EdgeTable.html",
    "href": "python/reference/EdgeTable.html",
    "title": "1 EdgeTable",
    "section": "",
    "text": "1 EdgeTable\nEdgeTable()\nDefines the connections between nodes."
  },
  {
    "objectID": "python/reference/Model.html",
    "href": "python/reference/Model.html",
    "title": "1 Model",
    "section": "",
    "text": "1 Model\nModel()"
  },
  {
    "objectID": "python/reference/nodes.user_demand.html",
    "href": "python/reference/nodes.user_demand.html",
    "title": "1 nodes.user_demand",
    "section": "",
    "text": "1 nodes.user_demand\nnodes.user_demand"
  },
  {
    "objectID": "python/reference/nodes.pump.html",
    "href": "python/reference/nodes.pump.html",
    "title": "1 nodes.pump",
    "section": "",
    "text": "1 nodes.pump\nnodes.pump"
  },
  {
    "objectID": "python/test-models.html",
    "href": "python/test-models.html",
    "title": "Test models",
    "section": "",
    "text": "Ribasim developers use the following models in their testbench and in order to test new features.\n\n\nCode\nimport ribasim_testmodels\nimport matplotlib.pyplot as plt\n\nfor model_name, model_constructor in ribasim_testmodels.constructors.items():\n    if model_name.startswith(\"invalid\"):\n        continue\n\n    model = model_constructor()\n    fig, ax = plt.subplots()\n    model.plot(ax)\n    ax.set_title(label=model_name, loc=\"left\")\n    fig.text(0, 1, model_constructor.__doc__)\n    fig.tight_layout()\n    plt.show()\n    plt.close(fig)",
    "crumbs": [
      "Python tooling",
      "Test models"
    ]
  },
  {
    "objectID": "contribute/python.html",
    "href": "contribute/python.html",
    "title": "Python tooling development",
    "section": "",
    "text": "In order to run tests on Ribasim Python execute\npixi run test-ribasim-python\n\n\n\nMake sure to run Clear All Outputs on the notebook before committing.\n\n\n\nBefore running the Julia tests or building binaries, example model input needs to created. This is done by running the following:\npixi run generate-testmodels\nThis places example model input files under ./generated_testmodels/. If the example models change, re-run this script.\n\n\n\nInstall the Python, ruff and autoDocstring extensions.\n\n\n\nTo run our linting suite locally, execute:\npixi run lint",
    "crumbs": [
      "Contributing",
      "Python tooling development"
    ]
  },
  {
    "objectID": "contribute/python.html#sec-test",
    "href": "contribute/python.html#sec-test",
    "title": "Python tooling development",
    "section": "",
    "text": "In order to run tests on Ribasim Python execute\npixi run test-ribasim-python",
    "crumbs": [
      "Contributing",
      "Python tooling development"
    ]
  },
  {
    "objectID": "contribute/python.html#updating-example-notebooks",
    "href": "contribute/python.html#updating-example-notebooks",
    "title": "Python tooling development",
    "section": "",
    "text": "Make sure to run Clear All Outputs on the notebook before committing.",
    "crumbs": [
      "Contributing",
      "Python tooling development"
    ]
  },
  {
    "objectID": "contribute/python.html#prepare-model-input",
    "href": "contribute/python.html#prepare-model-input",
    "title": "Python tooling development",
    "section": "",
    "text": "Before running the Julia tests or building binaries, example model input needs to created. This is done by running the following:\npixi run generate-testmodels\nThis places example model input files under ./generated_testmodels/. If the example models change, re-run this script.",
    "crumbs": [
      "Contributing",
      "Python tooling development"
    ]
  },
  {
    "objectID": "contribute/python.html#sec-vscode",
    "href": "contribute/python.html#sec-vscode",
    "title": "Python tooling development",
    "section": "",
    "text": "Install the Python, ruff and autoDocstring extensions.",
    "crumbs": [
      "Contributing",
      "Python tooling development"
    ]
  },
  {
    "objectID": "contribute/python.html#linting",
    "href": "contribute/python.html#linting",
    "title": "Python tooling development",
    "section": "",
    "text": "To run our linting suite locally, execute:\npixi run lint",
    "crumbs": [
      "Contributing",
      "Python tooling development"
    ]
  },
  {
    "objectID": "contribute/index.html",
    "href": "contribute/index.html",
    "title": "Contributing",
    "section": "",
    "text": "Ribasim welcomes contributions.\nThere is developer documentation for the Julia core, Python tooling, and the QGIS plugin. A guide on how to add a new node type to both is written in adding node types. Release process describes the steps to follow when creating a new Ribasim release.",
    "crumbs": [
      "Contributing"
    ]
  },
  {
    "objectID": "contribute/index.html#clone-ribasim",
    "href": "contribute/index.html#clone-ribasim",
    "title": "Contributing",
    "section": "1.1 Clone Ribasim",
    "text": "1.1 Clone Ribasim\nIn order to have the Ribasim repository locally available, you can clone it with Git. Git can be installed from git-scm.com. Once installed, run the following command at a directory of your choice:\nIn order to have the Ribasim repository locally available, run the following command at a directory of your choice:\ngit clone https://github.com/Deltares/Ribasim.git\nTo continue with the following steps, make the root of the repository your working directory by running\ncd Ribasim",
    "crumbs": [
      "Contributing"
    ]
  },
  {
    "objectID": "contribute/index.html#setting-up-pixi",
    "href": "contribute/index.html#setting-up-pixi",
    "title": "Contributing",
    "section": "1.2 Setting up pixi",
    "text": "1.2 Setting up pixi\nFirst, set up pixi as described on their getting started page.\nThen set up the environment by running the following commands:\npixi run install\nThis will automatically install all required packages for development. Our pixi environment also provides an instance of Julia and QGIS. These will not conflict with any pre-installed applications, as long as you have the pixi environment enabled. You can do this in a terminal by calling pixi shell, or starting programs with pixi run julia, or pixi run qgis. This is also the way that we start visual studio code: pixi run code ..",
    "crumbs": [
      "Contributing"
    ]
  },
  {
    "objectID": "contribute/ci.html",
    "href": "contribute/ci.html",
    "title": "Continuous integration",
    "section": "",
    "text": "Continuous integration (CI) is about commits being merged frequently, resulting in new features being released frequently. When proposing new changes to the code base a pull request is opened. When a new commit in that pull request, a series of tests will be done to make sure that this commit is error-free and robust in different environments. This process drive each new development through building, testing, quality checking.\ngraph LR\n    A[New development]--&gt;B[Continuous integration]\n    B--&gt;C[Merge]\nThis page contains an extensive explanation on how the Ribasim continuous integration works.",
    "crumbs": [
      "Contributing",
      "Continuous integration"
    ]
  },
  {
    "objectID": "contribute/ci.html#conditions-of-using-teamcity",
    "href": "contribute/ci.html#conditions-of-using-teamcity",
    "title": "Continuous integration",
    "section": "2.1 Conditions of using TeamCity",
    "text": "2.1 Conditions of using TeamCity\nTeamCity only runs workflows with the following conditions:\n\nWhen the workflow would take too long to run on GitHub Action\nWhen the release depends on the artifacts of the workflow.\nWhen other TeamCity projects depend on artifacts of Ribasim (e.g. iMOD coupler)",
    "crumbs": [
      "Contributing",
      "Continuous integration"
    ]
  },
  {
    "objectID": "contribute/ci.html#release-process",
    "href": "contribute/ci.html#release-process",
    "title": "Continuous integration",
    "section": "2.2 Release process",
    "text": "2.2 Release process\nIn the release, we include the generated testmodels, Ribasim CLI on Windows and Linux, Ribasim QGIS, and the source code.\nWe have the following pipeline to generate artifects for releasing:\n\nGenerate Testmodels: produces generated_testmodels artifact which is part of the release.\nMake GitHub Release: uses artifacts and makes the release. TeamCity constantly monitors the GitHub repository. When a tag starts with v20 is added, it triggers the release process.\nBuild Ribasim: builds library and executable of Ribasim on Linux and Windows. The artifacts are tested in Test Ribasim Binaries and used by iMOD Coupler.\nTest Ribasim Binaries: tests libribasim artifact and ribasim_cli artifact on Linux and Windows\n\n\n\n\n\n\n\nNote\n\n\n\nMake GitHub Release does not publish artifacts of “Test Ribasim Binaries”. It only publishes artifacts of “Build Ribasim” if the beforementioned tests pass.\n\n\n\n\n\n\n\ngraph LR\n    A[Make GitHub Release]--&gt;B(Release)\n    F[Generate Testmodels]--&gt;A\n    G[Make QGIS plugin]--&gt;A\n    H[Build Ribasim]---D[Test Ribasim Binaries]\n    D--&gt;A",
    "crumbs": [
      "Contributing",
      "Continuous integration"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ribasim quick overview",
    "section": "",
    "text": "Decision makers need to balance the supply and demand of water at the river basin scale, under increasing environmental pressure. Ribasim allows users to model basins under current and changing conditions to evaluate and design and management of the water system. It is available as free and open source software under the MIT license. Besides a model simulation core, Ribasim also includes tooling to assist in building models from basic datasets and visualize results. The model and its results provides insights to decision makers, enabling them to build consensus amongst water users and make informed decisions about how to manage water resources optimally.\nThe model concept of Ribasim is composed of multiple layers: - a physical layer representing water bodies and associated infrastructure as well as abstractions, - a rule-based control layer to manage the infrastructure, and - (optionally) a priority-based allocation layer to take centralized decisions on user abstractions. - (optionally) a coupling layer to exchange fluxes and heads with other kernels\nTypically hydrological processes on land will be represented in detail by other models which can be coupled (online) to Ribasim with the help of iMOD Coupler. Currently, an online coupling with MODFLOW 6 (groundwater) and with Metaswap + MODFLOW 6 (unsaturated zone + groundwater) is available. The corresponding documentation can be found within the iMOD Suite Documentation.\nThis version of Ribasim is the follow up of the legacy Fortran kernel of Ribasim (version 7) applied world wide, the Fortran kernel SIMRES applied in the Netherlands, and the surface water models Distribution Model and Mozart of the Dutch National Hydrological Instrument."
  },
  {
    "objectID": "index.html#sec-physical",
    "href": "index.html#sec-physical",
    "title": "Ribasim quick overview",
    "section": "2.1 Physical layer",
    "text": "2.1 Physical layer\nTo represent the physical characteristics of the water system in an area, Ribasim allows you to divide the area into a network of connected representative elementary watersheds (Reggiani, Sivapalan, and Majid Hassanizadeh 1998). Within Ribasim, these elements are called basins, which are essentially buckets or reservoirs holding an aggregated volume of water bodies in an area. Basins are chained in a graph with connector nodes determining the exchange of water between the basins. These connector nodes can represent open water connections (e.g. bifurcations or resistance in a free flowing open water channel) or infrastructure elements such as pumps, gates or weirs. An overview of node types and associated data inputs is provided on the usage page, while the associated mathematical formations are described on the equations page."
  },
  {
    "objectID": "index.html#sec-control",
    "href": "index.html#sec-control",
    "title": "Ribasim quick overview",
    "section": "2.2 Control layer",
    "text": "2.2 Control layer\nInfrastructure elements are often controlled by humans to implement a certain water management strategy. Ribasim allows the configuration of conditional rules to influence the exchange of water between basins, either by setting inflow or outflow, or by controlling a water level. Control rules evaluate one or multiple conditions to change a parameter setting of an infrastructure element when the conditional criteria are met. Conditions can be either calculated values within the network as well as boundary conditions or (todo) external observations, i.e. observation values external to the model. An overview of node types and associated data inputs is provided on the usage page, while the associated mathematical formations are described on the equations page."
  },
  {
    "objectID": "index.html#sec-allocation",
    "href": "index.html#sec-allocation",
    "title": "Ribasim quick overview",
    "section": "2.3 Allocation layer",
    "text": "2.3 Allocation layer\nRibasim allows water users (water demands) to abstract water from the basins (i.e. from the physical layer) unless the water level drops below a minimum level. Under dry conditions, water managers may want to prioritize some abstractions over other abstractions. The Ribasim allocation layer can take care of this prioritization by reducing the abstraction rates of lower-priority demands to ensure that sufficient water remains available in the system for the higher-priority demands. The associated mathematical formulations are described on the allocation page. In case of large networks, a subdivision in a main network with subnetworks is recommended. For more details see the explanation of the simulation loop at the Julia core home page.\nThe layers and the main components and dataflows between the layers are shown in the next figure:\n\n\n\n\n\nflowchart TB\nphysical:::layer\nrbc:::layer\nallocation:::layer\nuser_demand\nbasin\nconnector[basin connector]\ncontrol[control rules]\ncondition\nalloc[global allocation]\n\nsubgraph physical[physical layer]\n    user_demand--&gt;|abstraction| basin\n    basin&lt;--&gt;|flow| connector\nend\n\nsubgraph rbc[rule based control layer]\n   condition --&gt; control\nend\n\nsubgraph allocation[allocation layer]\n    alloc\nend\n\nuser_demand--&gt;|request demand| alloc\nalloc--&gt;|assign allocation| user_demand\nbasin--&gt;|volume| alloc\nbasin --&gt; |volume or level| condition\nalloc --&gt; |optional flow update| control\ncontrol --&gt; |action| connector\n\n%% class definitions for C4 model\nclassDef layer fill:transparent,stroke-dasharray:5 5"
  },
  {
    "objectID": "qgis/index.html",
    "href": "qgis/index.html",
    "title": "QGIS plugin",
    "section": "",
    "text": "Install QGIS version 3.28 or higher.\n\n\nDownload ribasim_qgis.zip, see the download section.\nPlugins menu &gt; Manage and Install Plugins…\n\n\n\n\n\nSelect “Install from ZIP”:\n\nBrowse to the ribasim_qgis.zip file containing the plugin that was downloaded earlier\nClick “Install Plugin”\n\n\n\n\n\n\nStart the Ribasim plugin.\n\n\n\n\n\n\n\n\nIn QGIS, navigate to “Plugins &gt; Manage and Install Plugins &gt; All”. In the search bar, type: “iMOD”. Select the iMOD plugin, and click “Install”.\nAt least version 0.4.0 of the iMOD plugin is required.\nThe Time Series widget from the iMOD plugin is used for visualizing Ribasim results, which is described in Section 1.5. Documentation on the Time Series widget can be found in the iMOD documentation.\n\n\n\nOpen an existing model or create a new model. As an example of an existing model, you can use the “basic” model from generated_testmodels.zip, see the download section.\n\n\n\n\n\nCheck if your coordinate reference system (CRS) is set correctly.\n\n\n\n\n\nIf you are working with an unknown CRS, right click the model database group in Layers, and click “Set Group CRS…”.\n\n\n\n\n\nIf you are modeling the Netherlands, select “Amersfoort / RD New” (EPSG:28992).\n\n\n\n\n\n\n\n\n\n\n\nSelect the Node layer.\n\n\n\n\n\nTurn on the edit mode to be able to add nodes on the map.\n\n\n\n\n\nAdd nodes to the map with a left click and select the node type.\n\n\n\n\n\nTurn the edit mode off and save the edits to the Nodes layer.\n\n\n\n\n\n\n\n\nRight click a layer and select “Open Attribute Table”.\n\n\n\n\n\nClick the yellow pencil icon on the top left to enable editing, and copy and paste a record. A record can be selected by clicking on the row number.\n\n\n\n\n\nAdjust the content. If you prefer, it also works to copy data with the same columns from Excel. Turn off edit mode and save changes to the layer.\n\n\n\n\n\n\n\n\n\n\n\nMake sure the Snapping Toolbar is visible, by going to the View &gt; Toolbars menu. Turn on snapping mode by clicking the magnet and set the snapping distance to 25 pixels.\n\n\n\n\n\n\n\n\nSelect the Edge layer and turn on the edit mode.\n\n\n\n\n\nSelect “Add line feature”.\n\n\n\n\n\nCreate a connection by left clicking a source node and right clicking the destination node.\n\n\n\n\n\nNow leave the edit mode and save the results to the layer.\n\n\n\n\n\nUnzip the Ribasim command line interface, ribasim_cli.zip\nOpen your terminal and go to the directory where your TOML is stored. Now run path/to/ribasim_cli/ribasim ribasim.toml. Adjust the path to the ribasim_cli folder to where you placed it. This runs the model.\nIn your model directory there is now a results/ folder with basin.arrow and flow.arrow output files.\n\n\n\n\nBefore trying to inspect the results, verify that the run was successful and the output files are there.\nClick the “Time Series” button of the iMOD plugin.\n\n\n\n\n\nSelect the layer that you wish to plot. From the “Node” layer you can plot level or storage on Basin nodes. From the “Edge” layer you can plot flow over flow edges. Note that before switching between these, you typically have to click “Clear” to clear the selection. If you run a simulation with the model open in QGIS, you have to close and re-open the “iMOD Time Series Plot” panel for the new results to be loaded.\nSelect the variables that you want to plot.\n\n\n\n\n\nClick “Select points” and select a node by dragging a rectangle around it on the map. Hold the Ctrl key to select multiple nodes.\n\n\n\n\n\nThe associated time series are shown the the graph.\n\n\n\n\n\nOnly the “basin.arrow” and “flow.arrow” can be inspected with the “iMOD Time Series Plot” panel. All Arrow files can be loaded as a layer by dragging the files onto QGIS. Right click the layer and select “Open Attribute Table” to view the contents."
  },
  {
    "objectID": "qgis/index.html#start",
    "href": "qgis/index.html#start",
    "title": "QGIS plugin",
    "section": "",
    "text": "Install QGIS version 3.28 or higher.\n\n\nDownload ribasim_qgis.zip, see the download section.\nPlugins menu &gt; Manage and Install Plugins…\n\n\n\n\n\nSelect “Install from ZIP”:\n\nBrowse to the ribasim_qgis.zip file containing the plugin that was downloaded earlier\nClick “Install Plugin”\n\n\n\n\n\n\nStart the Ribasim plugin.\n\n\n\n\n\n\n\n\nIn QGIS, navigate to “Plugins &gt; Manage and Install Plugins &gt; All”. In the search bar, type: “iMOD”. Select the iMOD plugin, and click “Install”.\nAt least version 0.4.0 of the iMOD plugin is required.\nThe Time Series widget from the iMOD plugin is used for visualizing Ribasim results, which is described in Section 1.5. Documentation on the Time Series widget can be found in the iMOD documentation.\n\n\n\nOpen an existing model or create a new model. As an example of an existing model, you can use the “basic” model from generated_testmodels.zip, see the download section.\n\n\n\n\n\nCheck if your coordinate reference system (CRS) is set correctly.\n\n\n\n\n\nIf you are working with an unknown CRS, right click the model database group in Layers, and click “Set Group CRS…”.\n\n\n\n\n\nIf you are modeling the Netherlands, select “Amersfoort / RD New” (EPSG:28992)."
  },
  {
    "objectID": "qgis/index.html#edit-nodes",
    "href": "qgis/index.html#edit-nodes",
    "title": "QGIS plugin",
    "section": "",
    "text": "Select the Node layer.\n\n\n\n\n\nTurn on the edit mode to be able to add nodes on the map.\n\n\n\n\n\nAdd nodes to the map with a left click and select the node type.\n\n\n\n\n\nTurn the edit mode off and save the edits to the Nodes layer.\n\n\n\n\n\n\n\n\nRight click a layer and select “Open Attribute Table”.\n\n\n\n\n\nClick the yellow pencil icon on the top left to enable editing, and copy and paste a record. A record can be selected by clicking on the row number.\n\n\n\n\n\nAdjust the content. If you prefer, it also works to copy data with the same columns from Excel. Turn off edit mode and save changes to the layer."
  },
  {
    "objectID": "qgis/index.html#connect-nodes",
    "href": "qgis/index.html#connect-nodes",
    "title": "QGIS plugin",
    "section": "",
    "text": "Make sure the Snapping Toolbar is visible, by going to the View &gt; Toolbars menu. Turn on snapping mode by clicking the magnet and set the snapping distance to 25 pixels.\n\n\n\n\n\n\n\n\nSelect the Edge layer and turn on the edit mode.\n\n\n\n\n\nSelect “Add line feature”.\n\n\n\n\n\nCreate a connection by left clicking a source node and right clicking the destination node.\n\n\n\n\n\nNow leave the edit mode and save the results to the layer."
  },
  {
    "objectID": "qgis/index.html#run-a-model",
    "href": "qgis/index.html#run-a-model",
    "title": "QGIS plugin",
    "section": "",
    "text": "Unzip the Ribasim command line interface, ribasim_cli.zip\nOpen your terminal and go to the directory where your TOML is stored. Now run path/to/ribasim_cli/ribasim ribasim.toml. Adjust the path to the ribasim_cli folder to where you placed it. This runs the model.\nIn your model directory there is now a results/ folder with basin.arrow and flow.arrow output files."
  },
  {
    "objectID": "qgis/index.html#sec-results",
    "href": "qgis/index.html#sec-results",
    "title": "QGIS plugin",
    "section": "",
    "text": "Before trying to inspect the results, verify that the run was successful and the output files are there.\nClick the “Time Series” button of the iMOD plugin.\n\n\n\n\n\nSelect the layer that you wish to plot. From the “Node” layer you can plot level or storage on Basin nodes. From the “Edge” layer you can plot flow over flow edges. Note that before switching between these, you typically have to click “Clear” to clear the selection. If you run a simulation with the model open in QGIS, you have to close and re-open the “iMOD Time Series Plot” panel for the new results to be loaded.\nSelect the variables that you want to plot.\n\n\n\n\n\nClick “Select points” and select a node by dragging a rectangle around it on the map. Hold the Ctrl key to select multiple nodes.\n\n\n\n\n\nThe associated time series are shown the the graph.\n\n\n\n\n\nOnly the “basin.arrow” and “flow.arrow” can be inspected with the “iMOD Time Series Plot” panel. All Arrow files can be loaded as a layer by dragging the files onto QGIS. Right click the layer and select “Open Attribute Table” to view the contents."
  },
  {
    "objectID": "contribute/addnode.html",
    "href": "contribute/addnode.html",
    "title": "Adding node types",
    "section": "",
    "text": "Several parts of the code have to be made aware of the new node type. In the rest of this page we shall call our new node type NewNodeType.",
    "crumbs": [
      "Contributing",
      "Adding node types"
    ]
  },
  {
    "objectID": "contribute/addnode.html#parameters",
    "href": "contribute/addnode.html#parameters",
    "title": "Adding node types",
    "section": "1.1 Parameters",
    "text": "1.1 Parameters\nThe parameters object (defined in parameter.jl) passed to the ODE solver must be made aware of the new node type. Therefore define a struct in parameter.jl which holds the data for each node of the new node type:\nstruct NewNodeType &lt;: AbstractParameterNode\n    node_id::Vector{NodeID}\n    # Other fields\nend\nAnother abstract type which subtypes from AbstractParameterNode is called AbstractDemandNode. For creating new node type used in allocation, define a struct:\nstruct NewNodeType &lt;: AbstractDemandNode\n    node_id::Vector{NodeID}\n    # Other fields\nend\nThese fields do not have to correspond 1:1 with the input tables (see below). The vector with all node IDs that are of the new type in a given model is a mandatory field. Now you can:\n\nAdd new_node_type::NewNodeType to the Parameters object;\nAdd new_node_type = NewNodeType(db,config) to the function Parameters in read.jl and add new_node_type at the proper location in the Parameters constructor call.",
    "crumbs": [
      "Contributing",
      "Adding node types"
    ]
  },
  {
    "objectID": "contribute/addnode.html#reading-from-configuration",
    "href": "contribute/addnode.html#reading-from-configuration",
    "title": "Adding node types",
    "section": "1.2 Reading from configuration",
    "text": "1.2 Reading from configuration\nThere can be several schemas associated with a single node type. To define a schema for the new node type, add the following to schema.jl:\n@schema \"ribasim.newnodetype.static\" NewNodeTypeStatic\n\n\"\"\"\nnode_id: node ID of the NewNodeType node\n\"\"\"\n@version NewNodeTypeStaticV1 begin\n    node_id::Int32\n    # Other fields\nend\nHere static refers to data that does not change over time. For naming conventions of these schemas see Node usage. If a new schema contains a priority column for allocation, it must also be added to the list of all such schemas in the function get_all_priorities in util.jl.\nvalidation.jl deals with checking and applying a specific sorting order for the tabular data (default is sorting by node ID only), see sort_by_function and sorted_table!.\nNow we define the function that is called in the second bullet above, in read.jl:\nfunction NewNodeType(db::DB, config::Config)::NewNodeType\n    static = load_structvector(db, config, NewNodeTypeStaticV1)\n    defaults = (; foo = 1, bar = false)\n    # Process potential control states in the static data\n    parsed_parameters, valid = parse_static_and_time(db, config, \"NewNodeType\"; static, defaults)\n\n    if !valid\n        error(\"Errors occurred when parsing NewNodeType data.\")\n    end\n\n    # Unpack the fields of static as inputs for the NewNodeType constructor\n    return NewNodeType(\n        NodeID.(NodeType.NewNodeType, parsed_parameters.node_id),\n        parsed_parameters.some_property,\n        parsed_parameters.control_mapping)\nend",
    "crumbs": [
      "Contributing",
      "Adding node types"
    ]
  },
  {
    "objectID": "contribute/addnode.html#node-behavior",
    "href": "contribute/addnode.html#node-behavior",
    "title": "Adding node types",
    "section": "1.3 Node behavior",
    "text": "1.3 Node behavior\nIn general if the new node type dictates flow, the behaviour of the new node in the Ribasim core is defined in a method of the formulate_flow! function, which is called within the water_balance! (both in solve.jl) function being the right hand side of the system of differential equations solved by Ribasim. Here the details depend highly on the specifics of the node type. An example structure of a formulate_flow! method is given below.\nfunction formulate_flow!(new_node_type::NewNodeType, p::Parameters)::Nothing\n    # Retrieve relevant parameters\n    (; graph) = p\n    (; node_id, param_1, param_2) = new_node_type\n\n    # Loop over nodes of NewNodeType\n    for (i, id) in enumerate(node_id)\n        # compute e.g. flow based on param_1[i], param_2[i]\n    end\n\n    return nothing\nend\nIf the new node type is non-conservative, meaning it either adds or removes water from the model, these boundary flows also need to be recorded. This is done by storing it on the diagonal of the flow[from, to] matrix, e.g. flow[id, id] = q, where q is positive for water added to the model. Non-conservative node types need to be added to the nonconservative_nodetypes set such that this diagonal is set to a nonzero on creating the flow sparse matrix in the Connectivity constructor.",
    "crumbs": [
      "Contributing",
      "Adding node types"
    ]
  },
  {
    "objectID": "contribute/addnode.html#the-jacobian",
    "href": "contribute/addnode.html#the-jacobian",
    "title": "Adding node types",
    "section": "1.4 The Jacobian",
    "text": "1.4 The Jacobian\nSee Equations for a mathematical description of the Jacobian.\nBefore the Julia core runs its simulation, the sparsity structure jac_prototype of \\(J\\) is determined with get_jac_prototype in sparsity.jl. This function runs trough all node types and looks for nodes that create dependencies between states. It creates a sparse matrix of zeros and ones, where the ones denote locations of possible non-zeros in \\(J\\). Note that only nodes that set flows in the physical layer (or have their own state like PidControl) affect the sparsity structure.\nWe divide the various node types in groups based on what type of state dependencies they yield, and these groups are discussed below. Each group has its own method update_jac_prototype! in utils.jl for the sparsity structure induced by nodes of that group. NewNodeType should be added to the signature of one these methods, or to the list of node types that do not contribute to the Jacobian in the method of update_jac_prototype! whose signature contains node::AbstractParameterNode. Of course it is also possible that a new method of update_jac_prototype! has to be introduced.\nThe current dependency groups are:\n\nOut-neighbor dependencies: examples are TabulatedRatingCurve, Pump (the latter only in the reduction factor regime and not PID controlled). If the in-neighbor of a node of this group is a basin, then the storage of this basin affects itself and the storage of the outneighbor (or the basin one node further if it is connected with a FractionalFlow in between) if that is also a basin;\nEither-neighbor dependencies: examples are LinearResistance, ManningResistance. If either the in-neighbor or out-neighbor of a node of this group is a basin, the storage of this basin depends on itself. If both the in-neighbor and the out-neighbor are basins, their storages also depend on eachother.\nThe PidControl node is a special case which is discussed in equations.\n\nUsing jac_prototype the Jacobian of water_balance! is computed automatically using ForwardDiff.jl with memory management provided by PreallocationTools.jl. These computations make use of DiffCache and dual numbers.",
    "crumbs": [
      "Contributing",
      "Adding node types"
    ]
  },
  {
    "objectID": "contribute/addnode.html#python-class",
    "href": "contribute/addnode.html#python-class",
    "title": "Adding node types",
    "section": "2.1 Python class",
    "text": "2.1 Python class\nIn python/ribasim/ribasim/config.py add\n\nthe above defined schemas to the imports from ribasim.schemas. This requires code generation to work, see Finishing up;\na class of the following form with all schemas associated with the node type:\n\nclass NewNodeType(NodeModel):\n    static: TableModel[NewNodeTypeStaticSchema] = Field(\n        default_factory=TableModel[NewNodeTypeStaticSchema],\n        json_schema_extra={\"sort_keys\": [\"node_id\"]},\n    )\nIn python/ribasim/ribasim/__init__.py add\n\nNewNodeType to the imports from ribasim.config;\n\"NewNodeType\" to __all__.\n\nIn python/ribasim/ribasim/model.py, add\n\nNewNodeType to the imports from ribasim.config;\nnew_node_type as a parameter and in the docstring of the Model class.\n\nIn python/ribasim/ribasim/geometry/node.py add a color and shape description in the MARKERS and COLORS dictionaries.",
    "crumbs": [
      "Contributing",
      "Adding node types"
    ]
  },
  {
    "objectID": "contribute/core.html",
    "href": "contribute/core.html",
    "title": "Julia core development",
    "section": "",
    "text": "The computational core is one of the components of Ribasim as illustrated in the component overview.\nThe computational process can be divided in three phases:\n\nModel initialization\nRunning the simulation loop\nWriting the output files\n\nA more detailed sequence diagram of the simulation loop is available at the core home page.",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/core.html#install-optional-julia-libraries",
    "href": "contribute/core.html#install-optional-julia-libraries",
    "title": "Julia core development",
    "section": "2.1 Install optional Julia libraries",
    "text": "2.1 Install optional Julia libraries\nStart the Julia REPL by executing pixi run julia in your terminal. Within the REPL type ] to enter the Pkg REPL. For more information on how to use Pkg, see the Getting Started page in its documentation. There you can add Revise to your global environment.\npkg&gt; add Revise",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/core.html#setup-revise.jl",
    "href": "contribute/core.html#setup-revise.jl",
    "title": "Julia core development",
    "section": "2.2 Setup Revise.jl",
    "text": "2.2 Setup Revise.jl\nRevise.jl is a library that allows you to modify code and use the changes without restarting Julia. You can let it start automatically by following these instructions.",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/core.html#install-visual-studio-code-optional",
    "href": "contribute/core.html#install-visual-studio-code-optional",
    "title": "Julia core development",
    "section": "2.3 Install Visual Studio Code (optional)",
    "text": "2.3 Install Visual Studio Code (optional)\nThere is a section on editors and IDEs for Julia on https://julialang.org/, scroll down to see it. We use and recommend Microsoft’s free editor Visual Studio Code. When combined with the Julia extension it provides a powerful and interactive development experience. Make sure to have the correct environment when opening your IDE by running open-vscode.bat, or opening a pixi shell and then calling the command to open the editor of your choice.",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/core.html#sec-test",
    "href": "contribute/core.html#sec-test",
    "title": "Julia core development",
    "section": "3.1 Running tests",
    "text": "3.1 Running tests\nYou will want to run the testsuite on a regular basis to check if your changes had unexpected side effects. It is also a good way to find out if your development environment is set up correctly.\nBefore the tests can run, you need to prepare model input.\nWith the root of the repository as your working directory you can start the REPL with activated root environment by running the following:\njulia --project\nWhile not technically required, it is advised to import Ribasim first to catch installation issues early on.\njulia&gt; using Ribasim\nThen open the Pkg REPL by typing ] and execute:\npkg&gt; test Ribasim\nIn order to debug tests, you can run individual test items from Visual Studio Code. Click the green play icon in front of a test item, as show in the image below. The first run will be slow.",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/core.html#render-documentation",
    "href": "contribute/core.html#render-documentation",
    "title": "Julia core development",
    "section": "3.2 Render documentation",
    "text": "3.2 Render documentation\nExample models are created and simulated as part of the rendering of the documentation.\nIn order to preview documentation you can run the following command from the docs/ folder. Afterwards, a browser tab will open with the rendered documentation, updating it as you make changes.\npixi run quarto-preview\nThe documentation also includes Jupyter notebooks. Note that they are stored in the repository without any output, and this should stay this way to keep the repository small. The documentation rendering process adds the output by running the notebooks.\n\n\n\n\n\n\nTip\n\n\n\nThe Jupyter VS Code extension allows you to run Jupyter notebooks directly in VS Code.",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/core.html#run-ribasim-simulations",
    "href": "contribute/core.html#run-ribasim-simulations",
    "title": "Julia core development",
    "section": "3.3 Run Ribasim simulations",
    "text": "3.3 Run Ribasim simulations\nAssuming your working directory is the root of the repository, you can activate this project by entering the Pkg mode of the REPL with ] and execute:\npkg&gt; activate .\npkg&gt; instantiate\nPress backspace to go back to the Julia REPL. There you can run a model with:\njulia&gt; Ribasim.run(\"path/to/model/ribasim.toml\")\n\n\n\n\n\n\nTip\n\n\n\nThe Julia VS Code extension allows you to execute code cells in REPL. This is a very convenient way of executing only parts of your source file.",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/core.html#build-ribasim",
    "href": "contribute/core.html#build-ribasim",
    "title": "Julia core development",
    "section": "3.4 Build Ribasim",
    "text": "3.4 Build Ribasim\nThe Ribasim core can be built into an executable with a command line interface (CLI) and a shared library, libribasim. These products will run without a Julia installation. To create both these products at once, run:\npixi run build\nTo verify that the build was successful, you can run both these commands.\npixi run test-ribasim-api\npixi run test-ribasim-cli\nDuring development these steps are normally done on TeamCity, though in some cases it can be more convenient to build locally.",
    "crumbs": [
      "Contributing",
      "Julia core development"
    ]
  },
  {
    "objectID": "contribute/qgis.html",
    "href": "contribute/qgis.html",
    "title": "QGIS plugin development",
    "section": "",
    "text": "1 Set up the developer environment\nAfter you have installed the environment as described here you must still activate the QGIS plugins. The simplest way to do this is by running pixi run install-qgis-plugins. It grabs the latest version of the iMOD QGIS plugin and it makes a symlink to the ribasim_qgis folder so that QGIS can find it. It also installs plugins that make it possible to reload and debug your plugin while QGIS is open.\n\n\n\n\n\n\nNote\n\n\n\nOn Windows you need to have Developer mode enabled. Otherwise you will not have enough access rights to create symlinks. For more info, see this Windows blog.\nWe wanted to implement this via pip install --editable, but QGIS doesn’t find the metadata.txt and therefore cannot load the plugin on startup.\n\n\n\n\n2 Running QGIS\nIn order to run QGIS with the plugins, simply call pixi run qgis. You will find the Ribasim and iMOD plugins in the tool bars.\n\n\n\n\n\n\nNote\n\n\n\nOn Windows, running QGIS from the start menu will disable Python, and thus the plugins. QGIS needs some more paths during the startup and the Pixi environment provides those.\n\n\n\n\n3 Running tests\nTo run the QGIS plugin tests in the application environment of QGIS, it is best to make use of the Docker environment provided in this repository. Make sure that docker is installed and available in your path.\nThen simply call pixi run test-ribasim-qgis.\n\n\n4 Debugging\nAfter installing the plugins via pixi run install-qgis-plugins. Extra debugging tools are also installed in QGIS that is installed within your pixi environment.\nAfter you have started pixi run qgis, you can make alterations to the Python code and use the Plugin Reloader to reload the plugin without restarting QGIS. The shortcut in QGIS is CTRL+F5.\nIt is also possible to connect the debugger of Visual Studio Code. For this the debugvs plugin is installed in QGIS. In QGIS press the button to Enable Debug for Visual Studio. Then go to Visual Studio Code and start the launch task Ribasim QGIS: Attach to QGIS. Now you can place breakpoints.\n\n\n\n\n\n\nNote\n\n\n\nWe are currently using debugvs 0.7 with ptvsd as service, since there is an open issue that breaks debugvs 0.8 with debugpy.",
    "crumbs": [
      "Contributing",
      "QGIS plugin development"
    ]
  },
  {
    "objectID": "contribute/release.html",
    "href": "contribute/release.html",
    "title": "Release process",
    "section": "",
    "text": "The Ribasim repository contains several components, e.g., the Julia core, the Python tooling and QGIS plugin. The components are currently only guaranteed to work together if they have the same version number. Therefore we release Ribasim as a collection of all the components at once, all carrying the same version number. For maximum interoperability it is suggested to only release all components together, and not individually.\nFor these releases we use Calender Versioning, which makes it clear in which month the release was made.",
    "crumbs": [
      "Contributing",
      "Release process"
    ]
  },
  {
    "objectID": "contribute/release.html#pre-release-checks",
    "href": "contribute/release.html#pre-release-checks",
    "title": "Release process",
    "section": "2.1 Pre-release checks",
    "text": "2.1 Pre-release checks\nBefore starting the release process, ensure that all tests are passing and that all features intended for the release are complete and merged into the main branch.",
    "crumbs": [
      "Contributing",
      "Release process"
    ]
  },
  {
    "objectID": "contribute/release.html#update-version-numbers-of-the-components",
    "href": "contribute/release.html#update-version-numbers-of-the-components",
    "title": "Release process",
    "section": "2.2 Update version numbers of the components",
    "text": "2.2 Update version numbers of the components\nDetermine the new version number like 2023.1.0, filling in the current year, a bumped MINOR number for normal releases and a bumped MICRO number for non-breaking, hotfix releases. This follows YYYY.MINOR.MICRO from calver.\nUpdate the version numbers in the repository to the new version number. A single find and replace can update all locations. The Ribasim version number is not in pixi.lock, that file does not need updating.\nNow submit a pull request to update the version numbers.",
    "crumbs": [
      "Contributing",
      "Release process"
    ]
  },
  {
    "objectID": "contribute/release.html#create-a-new-release",
    "href": "contribute/release.html#create-a-new-release",
    "title": "Release process",
    "section": "2.3 Create a new release",
    "text": "2.3 Create a new release\nWhen the pull request is merged to main, checkout the commit that updates the version numbers.\nCreate a new tag, which is the letter v followed by the version number, like, v2023.8.0.\nThis can be done by executing:\ngit tag &lt;tagname&gt;\nThen push the tags:\ngit push --tags\nThis will trigger a workflow on TeamCity that will publish a new release on GitHub as soon as it is finished. You can follow the progress here. It also auto-generates a changelog. You’ll probably want to curate that by rearranging the most important changes for users to the top in the form of Keep a Changelog. The possibly long list of generated release notes can put below an “All changes” collapsed item as such:\n&lt;details&gt;\n&lt;summary&gt;\nAll changes\n&lt;/summary&gt;\n\n# Put GitHub flavored markdown here\n\n&lt;/details&gt;",
    "crumbs": [
      "Contributing",
      "Release process"
    ]
  },
  {
    "objectID": "contribute/release.html#release-the-ribasim-python-packages-to-pypi",
    "href": "contribute/release.html#release-the-ribasim-python-packages-to-pypi",
    "title": "Release process",
    "section": "2.4 Release the Ribasim Python packages to PyPI",
    "text": "2.4 Release the Ribasim Python packages to PyPI\nTo be able to install packages with pip, they need to be released on the Python Package Index (PyPI). In order to publish Ribasim Python or Ribasim API follow the following steps:\n\nOpen a terminal and run pixi run publish-ribasim-python\nOpen a terminal and run pixi run publish-ribasim-api",
    "crumbs": [
      "Contributing",
      "Release process"
    ]
  },
  {
    "objectID": "contribute/release.html#do-manual-checks",
    "href": "contribute/release.html#do-manual-checks",
    "title": "Release process",
    "section": "2.5 Do manual checks",
    "text": "2.5 Do manual checks\nOur continuous integration (CI) should have caught most issues. A current weak spot in our testing is the QGIS plugin, so it is a good idea to do some manual checks to see if it works properly. Start with running the automated task to see if it can be correctly installed.\n# This test might give a fatal error on the first run, this is most likely a timing issue.\n# Try to run it again when that happens.\npixi run test-ribasim-qgis-ui\nIt is a good idea to load new test models if there are any, or test any other changed functionality.",
    "crumbs": [
      "Contributing",
      "Release process"
    ]
  },
  {
    "objectID": "contribute/release.html#announce-release",
    "href": "contribute/release.html#announce-release",
    "title": "Release process",
    "section": "2.6 Announce release",
    "text": "2.6 Announce release\nAnnounce the release in appropriate channels. Include a link to the release notes and assets, which is whatever this resolves to at that time. Also include a link to the documentation.",
    "crumbs": [
      "Contributing",
      "Release process"
    ]
  },
  {
    "objectID": "python/reference/nodes.level_demand.html",
    "href": "python/reference/nodes.level_demand.html",
    "title": "1 nodes.level_demand",
    "section": "",
    "text": "1 nodes.level_demand\nnodes.level_demand"
  },
  {
    "objectID": "python/reference/nodes.level_boundary.html",
    "href": "python/reference/nodes.level_boundary.html",
    "title": "1 nodes.level_boundary",
    "section": "",
    "text": "1 nodes.level_boundary\nnodes.level_boundary"
  },
  {
    "objectID": "python/reference/index.html",
    "href": "python/reference/index.html",
    "title": "1 API Reference",
    "section": "",
    "text": "The Model class represents an entire Ribasim model.\n\n\n\nModel\n\n\n\n\n\n\n\nThe Edge database layer.\n\n\n\nEdgeTable\nDefines the connections between nodes.\n\n\n\n\n\n\nAvailable node types to model different situations.\n\n\n\nnodes.basin\n\n\n\nnodes.fractional_flow\n\n\n\nnodes.tabulated_rating_curve\n\n\n\nnodes.pump\n\n\n\nnodes.outlet\n\n\n\nnodes.user_demand\n\n\n\nnodes.level_boundary\n\n\n\nnodes.flow_boundary\n\n\n\nnodes.linear_resistance\n\n\n\nnodes.manning_resistance\n\n\n\nnodes.terminal\n\n\n\nnodes.discrete_control\n\n\n\nnodes.pid_control\n\n\n\nnodes.flow_demand\n\n\n\nnodes.level_demand",
    "crumbs": [
      "Python tooling",
      "API Reference"
    ]
  },
  {
    "objectID": "python/reference/index.html#model",
    "href": "python/reference/index.html#model",
    "title": "1 API Reference",
    "section": "",
    "text": "The Model class represents an entire Ribasim model.\n\n\n\nModel",
    "crumbs": [
      "Python tooling",
      "API Reference"
    ]
  },
  {
    "objectID": "python/reference/index.html#edge",
    "href": "python/reference/index.html#edge",
    "title": "1 API Reference",
    "section": "",
    "text": "The Edge database layer.\n\n\n\nEdgeTable\nDefines the connections between nodes.",
    "crumbs": [
      "Python tooling",
      "API Reference"
    ]
  },
  {
    "objectID": "python/reference/index.html#node-types",
    "href": "python/reference/index.html#node-types",
    "title": "1 API Reference",
    "section": "",
    "text": "Available node types to model different situations.\n\n\n\nnodes.basin\n\n\n\nnodes.fractional_flow\n\n\n\nnodes.tabulated_rating_curve\n\n\n\nnodes.pump\n\n\n\nnodes.outlet\n\n\n\nnodes.user_demand\n\n\n\nnodes.level_boundary\n\n\n\nnodes.flow_boundary\n\n\n\nnodes.linear_resistance\n\n\n\nnodes.manning_resistance\n\n\n\nnodes.terminal\n\n\n\nnodes.discrete_control\n\n\n\nnodes.pid_control\n\n\n\nnodes.flow_demand\n\n\n\nnodes.level_demand",
    "crumbs": [
      "Python tooling",
      "API Reference"
    ]
  },
  {
    "objectID": "python/reference/nodes.terminal.html",
    "href": "python/reference/nodes.terminal.html",
    "title": "1 nodes.terminal",
    "section": "",
    "text": "1 nodes.terminal\nnodes.terminal"
  },
  {
    "objectID": "python/reference/nodes.manning_resistance.html",
    "href": "python/reference/nodes.manning_resistance.html",
    "title": "1 nodes.manning_resistance",
    "section": "",
    "text": "1 nodes.manning_resistance\nnodes.manning_resistance"
  },
  {
    "objectID": "python/reference/nodes.outlet.html",
    "href": "python/reference/nodes.outlet.html",
    "title": "1 nodes.outlet",
    "section": "",
    "text": "1 nodes.outlet\nnodes.outlet"
  },
  {
    "objectID": "python/reference/nodes.linear_resistance.html",
    "href": "python/reference/nodes.linear_resistance.html",
    "title": "1 nodes.linear_resistance",
    "section": "",
    "text": "1 nodes.linear_resistance\nnodes.linear_resistance"
  },
  {
    "objectID": "python/reference/nodes.flow_demand.html",
    "href": "python/reference/nodes.flow_demand.html",
    "title": "1 nodes.flow_demand",
    "section": "",
    "text": "1 nodes.flow_demand\nnodes.flow_demand"
  },
  {
    "objectID": "python/reference/nodes.discrete_control.html",
    "href": "python/reference/nodes.discrete_control.html",
    "title": "1 nodes.discrete_control",
    "section": "",
    "text": "1 nodes.discrete_control\nnodes.discrete_control"
  },
  {
    "objectID": "python/examples.html",
    "href": "python/examples.html",
    "title": "Examples",
    "section": "",
    "text": "1 Basic model with static forcing\n\nimport shutil\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom ribasim import Allocation, Model, Node\nfrom ribasim.nodes import (\n    basin,\n    discrete_control,\n    flow_boundary,\n    fractional_flow,\n    level_boundary,\n    level_demand,\n    linear_resistance,\n    manning_resistance,\n    outlet,\n    pid_control,\n    pump,\n    tabulated_rating_curve,\n    user_demand,\n)\nfrom shapely.geometry import Point\n\n\ndatadir = Path(\"data\")\nshutil.rmtree(datadir, ignore_errors=True)\n\n\nmodel = Model(starttime=\"2020-01-01\", endtime=\"2021-01-01\", crs=\"EPSG:4326\")\n\nSetup the basins:\n\ntime = pd.date_range(model.starttime, model.endtime)\nday_of_year = time.day_of_year.to_numpy()\nseconds_per_day = 24 * 60 * 60\nevaporation = (\n    (-1.0 * np.cos(day_of_year / 365.0 * 2 * np.pi) + 1.0) * 0.0025 / seconds_per_day\n)\nrng = np.random.default_rng(seed=0)\nprecipitation = (\n    rng.lognormal(mean=-1.0, sigma=1.7, size=time.size) * 0.001 / seconds_per_day\n)\n\n# Convert steady forcing to m/s\n# 2 mm/d precipitation, 1 mm/d evaporation\n\nbasin_data = [\n    basin.Profile(area=[0.01, 1000.0], level=[0.0, 1.0]),\n    basin.Time(\n        time=pd.date_range(model.starttime, model.endtime),\n        drainage=0.0,\n        potential_evaporation=evaporation,\n        infiltration=0.0,\n        precipitation=precipitation,\n        urban_runoff=0.0,\n    ),\n    basin.State(level=[1.4]),\n]\n\nmodel.basin.add(Node(1, Point(0.0, 0.0)), basin_data)\nmodel.basin.add(Node(3, Point(2.0, 0.0)), basin_data)\nmodel.basin.add(Node(6, Point(3.0, 2.0)), basin_data)\nmodel.basin.add(Node(9, Point(5.0, 0.0)), basin_data)\n\nSetup linear resistance:\n\nmodel.linear_resistance.add(\n    Node(10, Point(6.0, 0.0)),\n    [linear_resistance.Static(resistance=[5e3])],\n)\nmodel.linear_resistance.add(\n    Node(12, Point(2.0, 1.0)),\n    [linear_resistance.Static(resistance=[3600.0 * 24.0 / 100.0])],\n)\n\nSetup Manning resistance:\n\nmodel.manning_resistance.add(\n    Node(2, Point(1.0, 0.0)),\n    [\n        manning_resistance.Static(\n            length=[900], manning_n=[0.04], profile_width=[6.0], profile_slope=[3.0]\n        )\n    ],\n)\n\nSet up a rating curve node:\n\nmodel.tabulated_rating_curve.add(\n    Node(4, Point(3.0, 0.0)),\n    [tabulated_rating_curve.Static(level=[0.0, 1.0], flow_rate=[0.0, 10 / 86400])],\n)\n\nSetup fractional flows:\n\nmodel.fractional_flow.add(\n    Node(5, Point(3.0, 1.0)), [fractional_flow.Static(fraction=[0.3])]\n)\nmodel.fractional_flow.add(\n    Node(8, Point(4.0, 0.0)), [fractional_flow.Static(fraction=[0.6])]\n)\nmodel.fractional_flow.add(\n    Node(13, Point(3.0, -1.0)),\n    [fractional_flow.Static(fraction=[0.1])],\n)\n\nSetup pump:\n\nmodel.pump.add(Node(7, Point(4.0, 1.0)), [pump.Static(flow_rate=[0.5 / 3600])])\n\nSetup level boundary:\n\nmodel.level_boundary.add(\n    Node(11, Point(2.0, 2.0)), [level_boundary.Static(level=[0.5])]\n)\nmodel.level_boundary.add(\n    Node(17, Point(6.0, 1.0)), [level_boundary.Static(level=[1.5])]\n)\n\nSetup flow boundary:\n\nmodel.flow_boundary.add(\n    Node(15, Point(3.0, 3.0)), [flow_boundary.Static(flow_rate=[1e-4])]\n)\nmodel.flow_boundary.add(\n    Node(16, Point(0.0, 1.0)), [flow_boundary.Static(flow_rate=[1e-4])]\n)\n\nSetup terminal:\n\nmodel.terminal.add(Node(14, Point(3.0, -2.0)))\n\nSetup the edges:\n\nmodel.edge.add(model.basin[1], model.manning_resistance[2])\nmodel.edge.add(model.manning_resistance[2], model.basin[3])\nmodel.edge.add(model.basin[3], model.tabulated_rating_curve[4])\nmodel.edge.add(model.tabulated_rating_curve[4], model.fractional_flow[5])\nmodel.edge.add(model.tabulated_rating_curve[4], model.fractional_flow[8])\nmodel.edge.add(model.fractional_flow[5], model.basin[6])\nmodel.edge.add(model.basin[6], model.pump[7])\nmodel.edge.add(model.fractional_flow[8], model.basin[9])\nmodel.edge.add(model.pump[7], model.basin[9])\nmodel.edge.add(model.basin[9], model.linear_resistance[10])\nmodel.edge.add(model.level_boundary[11], model.linear_resistance[12])\nmodel.edge.add(model.linear_resistance[12], model.basin[3])\nmodel.edge.add(model.tabulated_rating_curve[4], model.fractional_flow[13])\nmodel.edge.add(model.fractional_flow[13], model.terminal[14])\nmodel.edge.add(model.flow_boundary[15], model.basin[6])\nmodel.edge.add(model.flow_boundary[16], model.basin[1])\nmodel.edge.add(model.linear_resistance[10], model.level_boundary[17])\n\nLet’s take a look at the model:\n\nmodel.plot()\n\n\n\n\n\n\n\n\nWrite the model to a TOML and GeoPackage:\n\ntoml_path = datadir / \"basic/ribasim.toml\"\nmodel.write(toml_path)\n\nPosixPath('data/basic/ribasim.toml')\n\n\nNow run the model. From Python you can run it with:\nimport subprocess\nsubprocess.run([cli_path, toml_path], check=True)\nOr similarly you can from the terminal with:\nribasim basic/ribasim.toml\nAfter running the model, read back the results:\n\ndf_basin = pd.read_feather(datadir / \"basic/results/basin.arrow\")\ndf_basin_wide = df_basin.pivot_table(\n    index=\"time\", columns=\"node_id\", values=[\"storage\", \"level\"]\n)\ndf_basin_wide[\"level\"].plot()\n\n\n\n\n\n\n\n\n\ndf_flow = pd.read_feather(datadir / \"basic/results/flow.arrow\")\ndf_flow[\"edge\"] = list(zip(df_flow.from_node_id, df_flow.to_node_id))\ndf_flow[\"flow_m3d\"] = df_flow.flow_rate * 86400\nax = df_flow.pivot_table(index=\"time\", columns=\"edge\", values=\"flow_m3d\").plot()\nax.legend(bbox_to_anchor=(1.3, 1), title=\"Edge\")\n\n\n\n\n\n\n\n\n\n\n2 Model with discrete control\nThe model constructed below consists of a single basin which slowly drains trough a TabulatedRatingCurve, but is held within a range by two connected pumps. These two pumps together behave like a reversible pump. When pumping can be done in only one direction, and the other direction is only possible under gravity, use an Outlet for that direction.\nSetup the basins:\n\nmodel = Model(starttime=\"2020-01-01\", endtime=\"2021-01-01\", crs=\"EPSG:4326\")\n\n\nmodel.basin.add(\n    Node(1, Point(0.0, 0.0)),\n    [\n        basin.Profile(area=[1000.0, 1000.0], level=[0.0, 1.0]),\n        basin.State(level=[20.0]),\n        basin.Time(time=[\"2020-01-01\", \"2020-07-01\"], precipitation=[0.0, 3e-6]),\n    ],\n)\n\nSetup the discrete control:\n\nmodel.discrete_control.add(\n    Node(7, Point(1.0, 0.0)),\n    [\n        discrete_control.Variable(\n            compound_variable_id=1,\n            listen_node_id=1,\n            listen_node_type=[\"Basin\"],\n            variable=[\"level\"],\n        ),\n        discrete_control.Condition(\n            compound_variable_id=1,\n            # min, max\n            greater_than=[5.0, 15.0],\n        ),\n        discrete_control.Logic(\n            truth_state=[\"FF\", \"TF\", \"TT\"],\n            control_state=[\"in\", \"none\", \"out\"],\n        ),\n    ],\n)\n\nThe above control logic can be summarized as follows:\n\nIf the level is above the maximum, activate the control state “out”;\nIf the level is below the minimum, active the control state “in”;\nOtherwise activate the control state “none”.\n\nSetup the pump:\n\nmodel.pump.add(\n    Node(2, Point(1.0, 1.0)),\n    [pump.Static(control_state=[\"none\", \"in\", \"out\"], flow_rate=[0.0, 2e-3, 0.0])],\n)\nmodel.pump.add(\n    Node(3, Point(1.0, -1.0)),\n    [pump.Static(control_state=[\"none\", \"in\", \"out\"], flow_rate=[0.0, 0.0, 2e-3])],\n)\n\nThe pump data defines the following:\n\n\n\nControl state\nPump #2 flow rate (m/s)\nPump #3 flow rate (m/s)\n\n\n\n\n“none”\n0.0\n0.0\n\n\n“in”\n2e-3\n0.0\n\n\n“out”\n0.0\n2e-3\n\n\n\nSetup the level boundary:\n\nmodel.level_boundary.add(\n    Node(4, Point(2.0, 0.0)), [level_boundary.Static(level=[10.0])]\n)\n\nSetup the rating curve:\n\nmodel.tabulated_rating_curve.add(\n    Node(5, Point(-1.0, 0.0)),\n    [tabulated_rating_curve.Static(level=[2.0, 15.0], flow_rate=[0.0, 2e-3])],\n)\n\nSetup the terminal:\n\nmodel.terminal.add(Node(6, Point(-2.0, 0.0)))\n\nSetup edges:\n\nmodel.edge.add(model.basin[1], model.pump[3])\nmodel.edge.add(model.pump[3], model.level_boundary[4])\nmodel.edge.add(model.level_boundary[4], model.pump[2])\nmodel.edge.add(model.pump[2], model.basin[1])\nmodel.edge.add(model.basin[1], model.tabulated_rating_curve[5])\nmodel.edge.add(model.tabulated_rating_curve[5], model.terminal[6])\nmodel.edge.add(model.discrete_control[7], model.pump[2])\nmodel.edge.add(model.discrete_control[7], model.pump[3])\n\nLet’s take a look at the model:\n\nmodel.plot()\n\n\n\n\n\n\n\n\nListen edges are plotted with a dashed line since they are not present in the “Edge / static” schema but only in the “Control / condition” schema.\n\ndatadir = Path(\"data\")\nmodel.write(datadir / \"level_range/ribasim.toml\")\n\nPosixPath('data/level_range/ribasim.toml')\n\n\nNow run the model with ribasim level_range/ribasim.toml. After running the model, read back the results:\n\ndf_basin = pd.read_feather(datadir / \"level_range/results/basin.arrow\")\ndf_basin_wide = df_basin.pivot_table(\n    index=\"time\", columns=\"node_id\", values=[\"storage\", \"level\"]\n)\n\nax = df_basin_wide[\"level\"].plot()\n\ngreater_than = model.discrete_control.condition.df.greater_than\n\nax.hlines(\n    greater_than,\n    df_basin.time[0],\n    df_basin.time.max(),\n    lw=1,\n    ls=\"--\",\n    color=\"k\",\n)\n\nax.set_yticks(greater_than, [\"min\", \"max\"])\nax.set_ylabel(\"level\")\nplt.show()\n\n\n\n\n\n\n\n\nWe see that in January the level of the basin is too high and thus water is pumped out until the maximum level of the desired range is reached. Then until May water flows out of the basin freely through the tabulated rating curve until the minimum level is reached. From this point until the start of July water is pumped into the basin in short bursts to stay within the desired range. At the start of July rain starts falling on the basin, which causes the basin level to rise until the maximum level. From this point onward water is pumped out of the basin in short bursts to stay within the desired range.\n\n\n3 Model with PID control\nSet up the model:\n\nmodel = Model(starttime=\"2020-01-01\", endtime=\"2020-12-01\", crs=\"EPSG:4326\")\n\nSetup the basins:\n\nmodel.basin.add(\n    Node(2, Point(1.0, 0.0)),\n    [basin.Profile(area=[1000.0, 1000.0], level=[0.0, 1.0]), basin.State(level=[6.0])],\n)\n\nSetup the pump:\n\nmodel.pump.add(\n    Node(3, Point(2.0, 0.5)),\n    [pump.Static(flow_rate=[0.0])],  # Will be overwritten by PID controller\n)\n\nSetup the outlet:\n\nmodel.outlet.add(\n    Node(6, Point(2.0, -0.5)),\n    [outlet.Static(flow_rate=[0.0])],  # Will be overwritten by PID controller\n)\n\nSetup flow boundary:\n\nmodel.flow_boundary.add(\n    Node(1, Point(0.0, 0.0)),\n    [flow_boundary.Static(flow_rate=[1e-3])],\n)\n\nSetup level boundary:\n\nmodel.level_boundary.add(\n    Node(4, Point(3.0, 0.0)),\n    [level_boundary.Static(level=[5.0])],\n)\n\nSetup PID control:\n\nfor node, proportional, integral in [\n    (Node(5, Point(1.5, 1.0)), -1e-3, -1e-7),\n    (Node(7, Point(1.5, -1.0)), 1e-3, 1e-7),\n]:\n    pid_control_data = [\n        pid_control.Time(\n            time=[\n                \"2020-01-01\",\n                \"2020-05-01\",\n                \"2020-07-01\",\n                \"2020-12-01\",\n            ],\n            listen_node_id=2,\n            listen_node_type=\"Basin\",\n            target=[5.0, 5.0, 7.5, 7.5],\n            proportional=proportional,\n            integral=integral,\n            derivative=0.0,\n        )\n    ]\n    model.pid_control.add(node, pid_control_data)\n\nNote that the coefficients for the pump and the outlet are equal in magnitude but opposite in sign. This way the pump and the outlet equally work towards the same goal, while having opposite effects on the controlled basin due to their connectivity to this basin.\nSetup the edges:\n\nmodel.edge.add(model.flow_boundary[1], model.basin[2])\nmodel.edge.add(model.basin[2], model.pump[3])\nmodel.edge.add(model.pump[3], model.level_boundary[4])\nmodel.edge.add(model.level_boundary[4], model.outlet[6])\nmodel.edge.add(model.outlet[6], model.basin[2])\nmodel.edge.add(model.pid_control[5], model.pump[3])\nmodel.edge.add(model.pid_control[7], model.outlet[6])\n\nLet’s take a look at the model:\n\nmodel.plot()\n\n\n\n\n\n\n\n\nWrite the model to a TOML and GeoPackage:\n\ndatadir = Path(\"data\")\nmodel.write(datadir / \"pid_control/ribasim.toml\")\n\nPosixPath('data/pid_control/ribasim.toml')\n\n\nNow run the model with ribasim pid_control/ribasim.toml. After running the model, read back the results:\n\nfrom matplotlib.dates import date2num\n\ndf_basin = pd.read_feather(datadir / \"pid_control/results/basin.arrow\")\ndf_basin_wide = df_basin.pivot_table(\n    index=\"time\", columns=\"node_id\", values=[\"storage\", \"level\"]\n)\nax = df_basin_wide[\"level\"].plot()\nax.set_ylabel(\"level [m]\")\n\n# Plot target level\nlevel_demands = model.pid_control.time.df.target.to_numpy()[:4]\ntimes = date2num(model.pid_control.time.df.time)[:4]\nax.plot(times, level_demands, color=\"k\", ls=\":\", label=\"target level\")\npass\n\n\n\n\n\n\n\n\n\n\n4 Model with allocation (user demand)\nSetup a model:\n\nmodel = Model(starttime=\"2020-01-01\", endtime=\"2020-01-20\", crs=\"EPSG:4326\")\n\nSetup the basins:\n\nbasin_data = [\n    basin.Profile(area=[300_000.0, 300_000.0], level=[0.0, 1.0]),\n    basin.State(level=[1.0]),\n]\n\nmodel.basin.add(\n    Node(2, Point(1.0, 0.0), subnetwork_id=1),\n    basin_data,\n)\nmodel.basin.add(\n    Node(5, Point(3.0, 0.0), subnetwork_id=1),\n    basin_data,\n)\nmodel.basin.add(\n    Node(12, Point(4.5, 1.0), subnetwork_id=1),\n    basin_data,\n)\n\nSetup the flow boundary:\n\nmodel.flow_boundary.add(\n    Node(1, Point(0.0, 0.0), subnetwork_id=1), [flow_boundary.Static(flow_rate=[2.0])]\n)\n\nSetup the linear resistance:\n\nmodel.linear_resistance.add(\n    Node(4, Point(2.0, 0.0), subnetwork_id=1),\n    [linear_resistance.Static(resistance=[0.06])],\n)\n\nSetup the tabulated rating curve:\n\nmodel.tabulated_rating_curve.add(\n    Node(7, Point(4.0, 0.0), subnetwork_id=1),\n    [tabulated_rating_curve.Static(level=[0.0, 0.5, 1.0], flow_rate=[0.0, 0.0, 2.0])],\n)\n\nSetup the fractional flow:\n\nmodel.fractional_flow.add(\n    Node(8, Point(4.5, 0.0), subnetwork_id=1),\n    [fractional_flow.Static(fraction=[0.6, 0.9], control_state=[\"divert\", \"close\"])],\n)\nmodel.fractional_flow.add(\n    Node(9, Point(4.5, 0.5), subnetwork_id=1),\n    [fractional_flow.Static(fraction=[0.4, 0.1], control_state=[\"divert\", \"close\"])],\n)\n\nSetup the terminal:\n\nmodel.terminal.add(Node(10, Point(5.0, 0.0), subnetwork_id=1))\n\nSetup the discrete control:\n\nmodel.discrete_control.add(\n    Node(11, Point(4.5, 0.25), subnetwork_id=1),\n    [\n        discrete_control.Variable(\n            compound_variable_id=1,\n            listen_node_id=[5],\n            listen_node_type=[\"Basin\"],\n            variable=[\"level\"],\n        ),\n        discrete_control.Condition(\n            compound_variable_id=1,\n            greater_than=[0.52],\n        ),\n        discrete_control.Logic(\n            truth_state=[\"T\", \"F\"], control_state=[\"divert\", \"close\"]\n        ),\n    ],\n)\n\nSetup the users:\n\nmodel.user_demand.add(\n    Node(6, Point(3.0, 1.0), subnetwork_id=1),\n    [\n        user_demand.Static(\n            demand=[1.5], return_factor=[0.0], min_level=[-1.0], priority=[1]\n        )\n    ],\n)\nmodel.user_demand.add(\n    Node(13, Point(5.0, 1.0), subnetwork_id=1),\n    [\n        user_demand.Static(\n            demand=[1.0], return_factor=[0.0], min_level=[-1.0], priority=[3]\n        )\n    ],\n)\nmodel.user_demand.add(\n    Node(3, Point(1.0, 1.0), subnetwork_id=1),\n    [\n        user_demand.Time(\n            demand=[0.0, 1.0, 1.2, 1.2],\n            return_factor=[0.0, 0.0, 0.0, 0.0],\n            min_level=[-1.0, -1.0, -1.0, -1.0],\n            priority=[1, 1, 2, 2],\n            time=2 * [\"2020-01-01\", \"2020-01-20\"],\n        )\n    ],\n)\n\nSetup the allocation:\n\nmodel.allocation = Allocation(use_allocation=True, timestep=86400)\n\nSetup the edges:\n\nmodel.edge.add(model.flow_boundary[1], model.basin[2], subnetwork_id=1)\nmodel.edge.add(model.basin[2], model.user_demand[3])\nmodel.edge.add(model.basin[2], model.linear_resistance[4])\nmodel.edge.add(model.linear_resistance[4], model.basin[5])\nmodel.edge.add(model.basin[5], model.user_demand[6])\nmodel.edge.add(model.basin[5], model.tabulated_rating_curve[7])\nmodel.edge.add(model.tabulated_rating_curve[7], model.fractional_flow[8])\nmodel.edge.add(model.user_demand[3], model.basin[2])\nmodel.edge.add(model.user_demand[6], model.basin[5])\nmodel.edge.add(model.tabulated_rating_curve[7], model.fractional_flow[9])\nmodel.edge.add(model.fractional_flow[8], model.terminal[10])\nmodel.edge.add(model.fractional_flow[9], model.basin[12])\nmodel.edge.add(model.basin[12], model.user_demand[13])\nmodel.edge.add(model.user_demand[13], model.terminal[10])\nmodel.edge.add(model.discrete_control[11], model.fractional_flow[8])\nmodel.edge.add(model.discrete_control[11], model.fractional_flow[9])\n\nLet’s take a look at the model:\n\nmodel.plot()\n\n\n\n\n\n\n\n\nWrite the model to a TOML and GeoPackage:\n\ndatadir = Path(\"data\")\nmodel.write(datadir / \"allocation_example/ribasim.toml\")\n\nPosixPath('data/allocation_example/ribasim.toml')\n\n\nNow run the model with ribasim allocation_example/ribasim.toml. After running the model, read back the results:\n\nimport matplotlib.ticker as plticker\n\ndf_allocation = pd.read_feather(datadir / \"allocation_example/results/allocation.arrow\")\ndf_allocation_wide = df_allocation.pivot_table(\n    index=\"time\",\n    columns=[\"node_type\", \"node_id\", \"priority\"],\n    values=[\"demand\", \"allocated\", \"realized\"],\n)\ndf_allocation_wide = df_allocation_wide.loc[:, (df_allocation_wide != 0).any(axis=0)]\n\nfig, axs = plt.subplots(1, 3, figsize=(8, 5))\n\ndf_allocation_wide[\"demand\"].plot(ax=axs[0], ls=\":\")\ndf_allocation_wide[\"allocated\"].plot(ax=axs[1], ls=\"--\")\ndf_allocation_wide.xs(1, level=\"priority\", axis=1)[\"realized\"].plot(\n    ax=axs[2], color=[\"C0\", \"C2\", \"C3\"]\n)\n\nfig.tight_layout()\nloc = plticker.MultipleLocator(2)\n\naxs[0].set_ylabel(\"level [m]\")\n\nfor ax, title in zip(axs, [\"Demand\", \"Allocated\", \"Abstracted\"]):\n    ax.set_title(title)\n    ax.set_ylim(0.0, 1.6)\n    ax.xaxis.set_major_locator(loc)\n\n\n\n\n\n\n\n\nSome things to note about this plot:\n\nThe realized flow at the start time is not correct, as there is no realized flow yet. The given value is how much of its total demand a user can abstract in the physical layer.\nNo flow was allocated to UserDemand 13 so that is not plotted.\nAbstraction is accumulated over all priorities per user.\n\n\ndf_basin = pd.read_feather(datadir / \"allocation_example/results/basin.arrow\")\ndf_basin_wide = df_basin.pivot_table(\n    index=\"time\", columns=\"node_id\", values=[\"storage\", \"level\"]\n)\n\nax = df_basin_wide[\"level\"].plot()\nax.set_title(\"Basin levels\")\nax.set_ylabel(\"level [m]\")\n\nText(0, 0.5, 'level [m]')\n\n\n\n\n\n\n\n\n\n\n\n5 Model with allocation (basin supply/demand)\nSetup a model:\n\nmodel = Model(starttime=\"2020-01-01\", endtime=\"2020-02-01\", crs=\"EPSG:4326\")\n\nSetup the basins:\n\nbasin_data = [\n    basin.Profile(area=[1e3, 1e3], level=[0.0, 1.0]),\n    basin.State(level=[0.5]),\n]\nmodel.basin.add(\n    Node(2, Point(1.0, 0.0), subnetwork_id=2),\n    [\n        *basin_data,\n        basin.Time(\n            time=[\"2020-01-01\", \"2020-01-16\"],\n            drainage=[0.0, 0.0],\n            potential_evaporation=[0.0, 0.0],\n            infiltration=[0.0, 0.0],\n            precipitation=[1e-6, 0.0],\n            urban_runoff=[0.0, 0.0],\n        ),\n    ],\n)\nmodel.basin.add(\n    Node(5, Point(2.0, -1.0), subnetwork_id=2),\n    [\n        *basin_data,\n        basin.Static(\n            drainage=[0.0],\n            potential_evaporation=[0.0],\n            infiltration=[0.0],\n            precipitation=[0.0],\n            urban_runoff=[0.0],\n        ),\n    ],\n)\n\nSetup the flow boundary:\n\nmodel.flow_boundary.add(\n    Node(1, Point(0.0, 0.0), subnetwork_id=2), [flow_boundary.Static(flow_rate=[1e-3])]\n)\n\nSetup level demand:\n\nmodel.level_demand.add(\n    Node(4, Point(1.0, -1.0), subnetwork_id=2),\n    [level_demand.Static(priority=[1], min_level=[1.0], max_level=[1.5])],\n)\n\nSetup the users:\n\nmodel.user_demand.add(\n    Node(3, Point(2.0, 0.0), subnetwork_id=2),\n    [\n        user_demand.Static(\n            priority=[2], demand=[1.5e-3], return_factor=[0.2], min_level=[0.2]\n        )\n    ],\n)\n\nSetup the allocation:\n\nmodel.allocation = Allocation(use_allocation=True, timestep=1e5)\n\nSetup the edges:\n\nmodel.edge.add(model.flow_boundary[1], model.basin[2], subnetwork_id=2)\nmodel.edge.add(model.basin[2], model.user_demand[3])\nmodel.edge.add(model.level_demand[4], model.basin[2])\nmodel.edge.add(model.user_demand[3], model.basin[5])\nmodel.edge.add(model.level_demand[4], model.basin[5])\n\nLet’s take a look at the model:\n\nmodel.plot()\n\n\n\n\n\n\n\n\nWrite the model to a TOML and GeoPackage:\n\nmodel.write(datadir / \"level_demand/ribasim.toml\")\n\nPosixPath('data/level_demand/ribasim.toml')\n\n\nNow run the model with ribasim level_demand/ribasim.toml. After running the model, read back the results:\n\ndf_basin = pd.read_feather(datadir / \"level_demand/results/basin.arrow\")\ndf_basin = df_basin[df_basin.node_id == 2]\ndf_basin_wide = df_basin.pivot_table(\n    index=\"time\", columns=\"node_id\", values=[\"storage\", \"level\"]\n)\nax = df_basin_wide[\"level\"].plot(ylabel=\"level [m]\")\n\n\n\n\n\n\n\n\nIn the plot above, the line denotes the level of Basin #2 over time. The Basin level is a piecewise linear function of time, with several stages explained below.\nConstants:\n\n\\(d\\): UserDemand #3 demand,\n\\(\\phi\\): Basin #2 precipitation rate,\n\\(q\\): LevelBoundary flow.\n\nStages:\n\nIn the first stage the Basin takes precedence so the UserDemand doesn’t abstract, hence the net change of Basin #2 is \\(q + \\phi\\);\nIn the second stage (and following stages) the Basin no longer has a positive demand, since precipitation provides enough water to get the Basin to its target level. The FlowBoundary flow gets fully allocated to the UserDemand, hence the net change of Basin #2 is \\(\\phi\\);\nIn the third stage the Basin enters its surplus stage, even though initially the level is below the maximum level. This is because the simulation anticipates that the current precipitation is going to bring the Basin level over its maximum level. The net change of Basin #2 is now \\(q + \\phi - d\\);\nAt the start of the fourth stage the precipitation stops, and so the UserDemand partly uses surplus water from the Basin to fulfill its demand. The net change of Basin #2 becomes \\(q - d\\).\nIn the final stage the Basin is in a dynamical equilibrium, since the Basin has no supply so the user abstracts precisely the flow from the LevelBoundary.\n\n\n\n6 Guidance of modelling a cascade of polder basins\nSituation description: This example shows how to make a model for a given practical water system, which consists of a cascade of level control polder basins with inlet and outlet to the main systems. Note that alternative model layouts are feasible for the same water system, each having its positive items and drawbacks.\n\nThe polder system is composed of a sequence of level controlled polder basins with weirs inbetween each basin and an inlet and outlet to main system\n\nmodel = Model(starttime=\"2020-01-01\", endtime=\"2021-01-01\", crs=\"EPSG:28992\")\n\nAll the polder basins are exposed to time varying forcings (precipitation, evaporation, drainage, infiltration) to mimic situations of water excess and water shortage.\nIn case of water excess, a pump in the most downstream polder will need to pump the surplus water to the main water system. In case of water shortage, an inlet at the most upstream polder will need to bring water into the cascase of polders. The main water system acts as a water source.\nModel approach: All polder basins as well as the main water system are modelled with basin nodes. To let the system experience all 4 excess/shortage situation, forcing time series are made in a way that is adapting to them. Overall, assume that in one year, the system will experience precipitation (situation 1) in winter and early spring, precipitation shortage (situation 2) from late spring until early autumn. During situation 2, polder basin 4 will experience additional seepage (compoensating its shortage), and later polder basin 3 will also receive more seepage.\nSetting up the basins:\n\ntime = pd.date_range(model.starttime, model.endtime)\nday_of_year = time.day_of_year.to_numpy()\n\nprecipitation = np.zeros(day_of_year.size)\nprecipitation[0:90] = 1.72e-8\nprecipitation[330:366] = 1.72e-8\n\nevaporation = np.zeros(day_of_year.size)\nevaporation[130:270] = 2.87e-8\n\ndrainage = np.zeros(day_of_year.size)\ndrainage[120:270] = 0.4 * 2.87e-8\ndrainage_3 = drainage.copy()\ndrainage_3[210:240] = 17 * 2.87e-8\ndrainage_4 = drainage.copy()\ndrainage_4[160:240] = 13 * 2.87e-8\n\ninfiltration = np.zeros(day_of_year.size)\ninfiltration[0:90] = 5e-8\n\npolder_profile = basin.Profile(area=[100, 100], level=[0.0, 3.0])\n\nbasin_time = [\n    basin.Time(\n        time=pd.date_range(model.starttime, model.endtime),\n        drainage=drainage,\n        potential_evaporation=evaporation,\n        infiltration=0.0,\n        precipitation=precipitation,\n        urban_runoff=0.0,\n    ),\n]\n\nbasin_time4 = [\n    basin.Time(\n        time=pd.date_range(model.starttime, model.endtime),\n        drainage=drainage_4,\n        potential_evaporation=evaporation,\n        infiltration=0.0,\n        precipitation=precipitation,\n        urban_runoff=0.0,\n    ),\n]\nbasin_time3 = [\n    basin.Time(\n        time=pd.date_range(model.starttime, model.endtime),\n        drainage=drainage_3,\n        potential_evaporation=evaporation,\n        infiltration=0.0,\n        precipitation=precipitation,\n        urban_runoff=0.0,\n    ),\n]\n\nmodel.basin.add(\n    Node(1, Point(2.0, 0.0)),\n    [\n        basin.State(level=[2.5]),\n        basin.Profile(area=[1000, 1000], level=[0.0, 3.0]),\n        basin.Time(\n            time=pd.date_range(model.starttime, model.endtime),\n            drainage=0.0,\n            potential_evaporation=0.0,\n            infiltration=0.0,\n            precipitation=0.0,\n            urban_runoff=0.0,\n        ),\n    ],\n)\nmodel.basin.add(\n    Node(4, Point(0.0, -2.0)),\n    [basin.State(level=[1.5]), polder_profile, *basin_time],\n)\nmodel.basin.add(\n    Node(6, Point(0.0, -4.0)),\n    [basin.State(level=[1.0]), polder_profile, *basin_time],\n)\nmodel.basin.add(\n    Node(8, Point(2.0, -4.0)),\n    [basin.State(level=[1.5]), polder_profile, *basin_time3],\n)\nmodel.basin.add(\n    Node(10, Point(4.0, -4.0)),\n    [basin.State(level=[1.3]), polder_profile, *basin_time4],\n)\nmodel.basin.add(\n    Node(12, Point(4.0, -2.0)),\n    [basin.State(level=[0.1]), polder_profile, *basin_time],\n)\n\nAfter all the basins are defined the connecting component inbetween the basins needs to be determined. For polder basin 5 (node 12), the water level needs to be maintain at 0.0 meter. This means that either there should be no water in this basin, or the basin bottom is lower than the reference level, and the water level should be maintained at the reference level.\nSince the water level of the main system is at 2.5 meter above the reference level a pump is needed to remove the water from polder basin 5.\nSetup the pumps:\n\nmodel.pump.add(\n    Node(13, Point(4.0, -1.0)),\n    [pump.Static(flow_rate=[0.5 / 3600])],\n)\n\nAccording to the description of situation 1 and 2, the water in one polder basin needs to be able to flow to the downstream basin if the current basin has too much water (i.e. the water level is above the setpoint) or if the downstream basin is below setpoint and needs more water. This could be modelled with an uncontrolled TabulatedRatingCurve node with Q=0 at the setpoint level (and Q rising when the level rises above setpoint) , or with an Outlet node where the minimum crest is specified at or just below the setpoint. In this example, we’ve chosen for the Outlet where we specify the minimum crest level 5 cm below the setpoint. For example: the Outlet of polder basin 1 (node 4) is specified with a minimum crest level of 1.95 meter.\nSetup the outlets:\n\n# Set up outlet\nmodel.outlet.add(\n    Node(2, Point(0.0, -1.0)),\n    [outlet.Static(flow_rate=[2 * 0.5 / 3600], min_crest_level=[0.0])],\n)\nmodel.outlet.add(\n    Node(5, Point(0.0, -3.0)),\n    [outlet.Static(flow_rate=[0.5 / 3600], min_crest_level=[1.95])],\n)\nmodel.outlet.add(\n    Node(7, Point(1.0, -4.0)),\n    [outlet.Static(flow_rate=[0.5 / 3600], min_crest_level=[1.45])],\n)\nmodel.outlet.add(\n    Node(9, Point(3.0, -4.0)),\n    [outlet.Static(flow_rate=[0.5 / 3600], min_crest_level=[0.95])],\n)\nmodel.outlet.add(\n    Node(11, Point(4.0, -3.0)),\n    [outlet.Static(flow_rate=[0.5 / 3600], min_crest_level=[0.45])],\n)\n\nWhen using Outlets as connecting nodes, the flow over the Outlet needs to be controlled to maintain the water level at the setpoint. For this purpose we introduce local PidControllers, where the targets of the PidControllers are set to the setpoints. Disadvantage of this local control approach is the delay that is introduced to transport the ‘basin X has a shortage’ message upstream through the cascade to the inlet. Current functionality does not offer the capability for PidControl to take multiple observations into account when controlling the inlet. Combining multiple observations in one control is feasible with DiscreteControl. This could be an alternative approach to controlling the inlet for the cascading water system.\nSetup the PID control:\n\npid_control_data = {\n    \"listen_node_type\": \"Basin\",\n    \"proportional\": [0.05],\n    \"integral\": [0.00],\n    \"derivative\": [0.0],\n}\nmodel.pid_control.add(\n    Node(3, Point(-1.0, -1.0)),\n    [pid_control.Static(listen_node_id=[4], target=[2.0], **pid_control_data)],\n)\nmodel.pid_control.add(\n    Node(14, Point(-1.0, -3.0)),\n    [pid_control.Static(listen_node_id=[6], target=[1.5], **pid_control_data)],\n)\nmodel.pid_control.add(\n    Node(15, Point(1.0, -3.0)),\n    [pid_control.Static(listen_node_id=[8], target=[1.0], **pid_control_data)],\n)\nmodel.pid_control.add(\n    Node(16, Point(3.0, -3.0)),\n    [pid_control.Static(listen_node_id=[10], target=[0.5], **pid_control_data)],\n)\n\nSetup the edges:\n\nmodel.edge.add(model.basin[1], model.outlet[2])\nmodel.edge.add(model.pid_control[3], model.outlet[2])\nmodel.edge.add(model.outlet[2], model.basin[4])\nmodel.edge.add(model.basin[4], model.outlet[5])\nmodel.edge.add(model.outlet[5], model.basin[6])\nmodel.edge.add(model.basin[6], model.outlet[7])\nmodel.edge.add(model.outlet[7], model.basin[8])\nmodel.edge.add(model.basin[8], model.outlet[9])\nmodel.edge.add(model.outlet[9], model.basin[10])\nmodel.edge.add(model.basin[10], model.outlet[11])\nmodel.edge.add(model.outlet[11], model.basin[12])\nmodel.edge.add(model.basin[12], model.pump[13])\nmodel.edge.add(model.pump[13], model.basin[1])\nmodel.edge.add(model.pid_control[14], model.outlet[5])\nmodel.edge.add(model.pid_control[15], model.outlet[7])\nmodel.edge.add(model.pid_control[16], model.outlet[9])\n\nTo plot the model\n\nmodel.plot()\n\n\n\n\n\n\n\n\nWrite the model to a TOML file and run it in the Julia.\n\ndatadir = Path(\"data\")\nmodel.write(datadir / \"local_pidcontrolled_cascade/ribasim.toml\")\n\nPosixPath('data/local_pidcontrolled_cascade/ribasim.toml')\n\n\nAfter running the model, read back the result to plot the flow of each polder basin.\n\ndatadir_flow = datadir / \"local_pidcontrolled_cascade/results/flow.arrow\"\ndf_flow = pd.read_feather(datadir_flow)\ndf_flow[\"edge\"] = list(zip(df_flow.from_node_id, df_flow.to_node_id))\ndf_flow[\"flow_m3d\"] = df_flow.flow_rate * 86400\n\ndf_pivot = df_flow.pivot_table(index=\"time\", columns=\"edge\", values=\"flow_m3d\")\n\nBelow graphs show the flow exchanged with the mainsystem (i.e. the inlet and the pump), and the flow of weirs inbetween the polder basins.\n\ndf_input = df_pivot.loc[:, [(1, 2), (13, 1)]]\ndf_input.plot(ylim=[-1.0, 20.0])\ndf_weirs = df_pivot.loc[:, [(4, 5), (6, 7), (8, 9), (10, 11)]]\ndf_weirs.plot(ylim=[-1.0, 15.0])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBelow graph shows the vertical flux on each basin.\n\ndatadir_basin = datadir / \"local_pidcontrolled_cascade/results/basin.arrow\"\ndf_basin = pd.read_feather(datadir_basin)\ndf_basin[\"vertical_flux\"] = (\n    df_basin[\"precipitation\"]\n    - df_basin[\"evaporation\"]\n    + df_basin[\"drainage\"]\n    + df_basin[\"infiltration\"]\n)\ndf_basin_wide = df_basin.pivot_table(\n    index=\"time\", columns=\"node_id\", values=[\"storage\", \"level\", \"vertical_flux\"]\n)\ndf_basin_wide[\"vertical_flux\"].plot()\n\n\n\n\n\n\n\n\nIn the following graph, the water level of basins are shown. The five polder basins are given starting levels that are different from their setpoints. It can be observed that in the beginning, the water level are changing and approaching to the set points. Later when the water levels are stable, they will not be affected by the forcing.\n\ndf_basin_wide[\"level\"].plot()",
    "crumbs": [
      "Python tooling",
      "Examples"
    ]
  },
  {
    "objectID": "core/index.html",
    "href": "core/index.html",
    "title": "Julia core",
    "section": "",
    "text": "With the term “core”, we mean the computational engine of Ribasim. As detailed in the usage documentation, it is generally used as a command line tool.\nA quick overview of the model concept is available at the home page, while a more in depth discussion is available on the model concept page. The theory is described on the equations page, and more in-depth numerical considerations are described on the numerical considerations page. As allocation is a large and self-contained part of the Ribasim core, it is described on the separate allocation page. Input validation is described on the validation page.\nThe core is implemented in the Julia programming language, and can be found in the Ribasim repository under the core/ folder. For developers we also advise to read the developer documentation. Information on coupling can be found here.\nAn overview of all components is given on the home page\n\n1 The simulation loop\nThe computational process can be divided in three phases:\n\nModel initialization\nRunning the simulation loop\nWriting the output files\n\nThe figure below gives a more detailed description of the simulation loop in the form of a sequence diagram. From top to bottom, it contains the following blocks:\n\nAllocation optimization; activated when the allocation timestep has been passed;\nControl actions; activated when some discrete control callback is triggered;\nWater balance; computing the flows over flow edges happens each timestep;\nTime integration step; done by the integrator from OrdinaryDiffEq.jl.\n\n\n\n\n\n\nsequenceDiagram\n    autonumber\n    participant Int as Process: Integrator\n    participant Optim as Process: Allocation optimization\n    participant Param as Data: Parameters\n    participant State as Data: State\n    participant Sim as Process: Water balance\n    loop Simulation loop (OrdinaryDiffEq.jl)\n        activate Int\n        %% Allocation\n        rect rgb(200, 200, 200)\n            opt Allocation optimization, per allocation network (JuMP.jl, HiGHS)\n                activate Optim\n                Int-&gt;&gt;Optim: Callback: allocation timestep has passed\n                Param--&gt;&gt;Optim: Input\n                State--&gt;&gt;Optim: Input\n                Optim-&gt;&gt;Optim: Optimize Basin allocations if below target level\n                Optim-&gt;&gt;Optim: Optimize UserDemand allocation, per priority\n                Optim--&gt;&gt;Param: Set allocated flow rates\n                deactivate Optim\n            end\n        end\n        %% Control\n        rect rgb(200, 200, 200)\n            opt Control actions\n                Int-&gt;&gt;Int: DiscreteControl callback\n                Int--&gt;&gt;Param: Parameter updates by control\n            end\n        end\n        %% water_balance!\n        rect rgb(200, 200, 200)\n            activate Sim\n            State--&gt;&gt;Sim: Input\n            Param--&gt;&gt;Sim: Input\n            Sim-&gt;&gt;Sim: Compute flows over edges per node type\n            Sim--&gt;&gt;Param: Set flows\n            deactivate Sim\n        end\n        %% Time integration\n        rect rgb(200, 200, 200)\n            State--&gt;&gt;Int: Input\n            Param--&gt;&gt;Int: Input\n            Int-&gt;&gt;Int: Time integration step\n            Int--&gt;&gt;State: Update state\n        end\n        deactivate Int\n  end\n\n\n\n\n\n\n\n\n2 Nested allocation\nSince water systems may be extensive, like in the Netherlands, Ribasim models may become large networks with over ten thousand nodes. To keep a proper functioning allocation concept under these circumstances, the modeller can decompose the network domain into a main network and multiple sub-networks. The allocation will then be conducted in three steps:\n\nconduct an inventory of demands from the sub-networks to inlets from the main network,\nallocate the available water in the main network to the subnetworks inlets,\nallocate the assigned water within each subnetwork to the individual demand nodes.\n\nThe demand nodes then will request this updated demand from the rule-based simulation. Whether this updated demand is indeed abstracted depends on all dry-fall control mechanism implemented in the rule-based simulation.\nThe following sequence diagram illustrates this calculation process within then allocation phase.\n\n\n\n\n\nsequenceDiagram\nparticipant boundary\nparticipant basin\nparticipant user_demand\nparticipant allocation_subNetwork\nparticipant allocation_mainNetwork\n\nuser_demand-&gt;&gt;allocation_subNetwork: demand\nloop\n   allocation_subNetwork--&gt;&gt;allocation_mainNetwork: demand inventory at inlets\nend\nuser_demand-&gt;&gt;allocation_mainNetwork: demand\nboundary-&gt;&gt;allocation_mainNetwork: source availability\nbasin-&gt;&gt;allocation_mainNetwork: source availability\nallocation_mainNetwork--&gt;&gt;allocation_mainNetwork: allocate to inlets (and user_demands)\nallocation_mainNetwork-&gt;&gt;user_demand: allocated\nallocation_mainNetwork-&gt;&gt;allocation_subNetwork: allocated\nloop\n   allocation_subNetwork--&gt;&gt;allocation_subNetwork: allocate to user_demands\nend\nallocation_subNetwork-&gt;&gt;user_demand: allocated\nuser_demand-&gt;&gt;basin: abstracted",
    "crumbs": [
      "Julia core"
    ]
  },
  {
    "objectID": "core/modelconcept.html",
    "href": "core/modelconcept.html",
    "title": "Model concept",
    "section": "",
    "text": "A brief summary of the concept is given on the documentation home page. As indicated, the model concept is organized in three layers:",
    "crumbs": [
      "Julia core",
      "Model concept"
    ]
  },
  {
    "objectID": "core/modelconcept.html#water-balance-equations",
    "href": "core/modelconcept.html#water-balance-equations",
    "title": "Model concept",
    "section": "1.1 Water balance equations",
    "text": "1.1 Water balance equations\nThe water balance equation for a drainage basin (Wikipedia contributors 2022) can be defined by a first-order ordinary differential equation (ODE), where the change of the storage \\(S\\) over time is determined by the inflow fluxes minus the outflow fluxes.\n\\[\n\\frac{\\mathrm{d}S}{\\mathrm{d}t} = Q_{in} - Q_{out}\n\\]\nWe can split out the fluxes into separate terms, such as precipitation \\(P\\), evapotranspiration \\(ET\\) and runoff \\(R\\). For now other fluxes are combined into \\(Q_{rest}\\). If we define all fluxes entering our reservoir as positive, and those leaving the system as negative, all fluxes can be summed up.\n\\[\n\\frac{\\mathrm{d}S}{\\mathrm{d}t} = R + P + ET + Q_{rest}\n\\]",
    "crumbs": [
      "Julia core",
      "Model concept"
    ]
  },
  {
    "objectID": "core/modelconcept.html#time",
    "href": "core/modelconcept.html#time",
    "title": "Model concept",
    "section": "1.2 Time",
    "text": "1.2 Time\nThe water balance equation can be applied on many timescales; years, weeks, days or hours. Depending on the application and available data any of these can be the best choice. In Ribasim, we make use of DifferentialEquations.jl and its ODE solvers. Many of these solvers are based on adaptive time stepping, which means the solver will decide how large the time steps can be depending on the state of the system.\nThe forcing, like precipitation, is generally provided as a time series. Ribasim is set up to support unevenly spaced timeseries. The solver will stop on timestamps where new forcing values are available, so they can be loaded as the new value.\nRibasim is essentially a continuous model, rather than daily or hourly. If you want to use hourly forcing, you only need to make sure that your forcing data contains hourly updates. The output frequency can be configured independently. To be able to write a closed water balance, we accumulate the fluxes. This way any variations in between timesteps are also included, and we can output in m³ rather than m³s⁻¹.",
    "crumbs": [
      "Julia core",
      "Model concept"
    ]
  },
  {
    "objectID": "core/modelconcept.html#sec-space",
    "href": "core/modelconcept.html#sec-space",
    "title": "Model concept",
    "section": "1.3 Space",
    "text": "1.3 Space\nThe water balance equation can be applied on different spatial scales. Besides modelling a single lumped watershed, it allows you to divide the area into a network of connected representative elementary watersheds (REWs) (Reggiani, Sivapalan, and Majid Hassanizadeh 1998). At this scale global water balance laws can be formulated by means of integration of point-scale conservation equations over control volumes. Such an approach makes Ribasim a semi-distributed model. In this document we typically use the term “basin” to refer to the REW. Each basin has an associated polygon, and the set of basins is connected to each other as described by a graph, which we call the network. Below is a representation of both on the map.\n\n\n\nMozart Local Surface Water polygons and their drainage.\n\n\nThe network is described as graph. Flow can be bi-directional, and the graph does not have to be acyclic.\n\n\n\n\n\ngraph LR;\n    A[\"basin A\"] --- B[\"basin B\"];\n    A --- C[\"basin C\"];\n    B --- D[\"basin D\"];\n    C --- D;\n\n\n\n\n\n\nInternally a directed graph is used. The direction is defined to be the positive flow direction, and is generally set in the dominant flow direction. The basins are the nodes of the network graph. Basin states and properties such storage volume and wetted area are associated with the nodes (A, B, C, D), as are most forcing data such as precipitation, evaporation, or water demand. Basin connection properties and interbasin flows are associated with the edges (the lines between A, B, C, and D) instead.\nMultiple basins may exist within the same spatial polygon, representing different aspects of the surface water system (perennial ditches, ephemeral ditches, or even surface ponding). Figure 1, Figure 2, Figure 3 show the 25.0 m rasterized primary, secondary, and tertiary surface waters as identified by BRT TOP10NL (PDOK 2022) in the Hupsel basin. These systems may represented in multiple ways.\n\n\n\n\n\n\nFigure 1: Hupsel: primary surface water.\n\n\n\n\n\n\n\n\n\nFigure 2: Hupsel: secondary surface water.\n\n\n\n\n\n\n\n\n\nFigure 3: Hupsel: tertiary surface water.\n\n\n\nAs a single basin (A) containing all surface water, discharging to its downstream basin to the west (B):\n\n\n\n\n\ngraph LR;\n    A[\"basin A\"] --&gt; B[\"basin B\"];\n\n\n\n\n\n\nSuch a system may be capable of representing discharge, but it cannot represent residence times or differences in solute concentrations: within a single basin, a drop of water is mixed instantaneously. Instead, we may the group primary (P), secondary (S), and tertiary (T) surface waters. Then T may flow into S, S into P, and P discharges to the downstream basin (B.)\n\n\n\n\n\ngraph LR;\n    T[\"basin T\"] --&gt; S[\"basin S\"];\n    S --&gt; P[\"basin P\"];\n    P --&gt; B[\"basin B\"];\n\n\n\n\n\n\nAs each (sub)basin has its own volume, low throughput (high volume, low discharge, long residence time) and high throughput (low volume, high discharge, short residence time) systems can be represented in a lumped manner; of course, more detail requires more parameters.",
    "crumbs": [
      "Julia core",
      "Model concept"
    ]
  },
  {
    "objectID": "core/modelconcept.html#structures-in-a-water-system",
    "href": "core/modelconcept.html#structures-in-a-water-system",
    "title": "Model concept",
    "section": "1.4 Structures in a water system",
    "text": "1.4 Structures in a water system\nIn addition to free flowing waterbodies, a watersystem typically has structures to control the flow of water. Ribasim uses connector nodes which simplify the hydraulic behaviour for the free flowing conditions or structures. The following type of connector nodes are available for this purpose:\n\nTabulatedRatingCurve: one-directional flow based on upstream head. Node type typically used for gravity flow conditions either free flowing open water channels or over a fixed structure.\nLinearResistance: bi-directional flow based on head difference and linear resistance. Node type typically used for bi-directional flow situations or situations where head difference over a structure determines its actual flow capacity.\nManningResistance: bi-directional flow based on head difference and resistance using Manning-Gauckler formula. Same usage as LinearResistance, providing a better hydrological meaning to the resistance parameterization.\nPump: one-directional structure with a set flow rate. Node type typically used in combination with control to force water over the edge.\nOutlet: one-directional gravity structure with a set flow rate. Node type typically used in combination with control to force water over the edge, even if their is a mismatch in actual hydraulic capacity. The node type has an automated mechanism to stop the flow when the head difference is zero.\nFractionalFlow: to split an outflow over multiple edges based on a flow fraction. Node type is typically used for diversions or bifurcations with a known and fixed ratio.\n\nThe control layer can activate or deactivate nodes, set flow rates for the Pump and Outlet, or choose different parameterizations for TabulatedRatingCurve, LinearResistance, ManningResistance or FractionalFlow.\nConnector nodes are required within a Ribasim network to determine the flow exchange between basins.",
    "crumbs": [
      "Julia core",
      "Model concept"
    ]
  },
  {
    "objectID": "core/numerics.html",
    "href": "core/numerics.html",
    "title": "Numerical considerations",
    "section": "",
    "text": "We want to solve the following initial value problem: \\[\n\\begin{cases}\n    \\frac{\\text{d}\\mathbf{u}}{\\text{d}t} = \\mathbf{f}(\\mathbf{u},t) \\quad t_0 &lt; t &lt; t_\\text{end} \\\\\n    \\mathbf{u}(t_0) = \\mathbf{u}_0\n\\end{cases},\n\\tag{1}\\]\nwhere \\(\\mathbf{f}\\) denotes water_balance! and \\(\\mathbf{u_0}\\) the initial storages (and the PID integrals which start out at \\(0\\)).\nIn general \\(\\mathbf{f}\\) is a non-linear function in \\(\\mathbf{u}\\). These non-linearities are introduced by:\nThe problem Equation 1 can be solved by various numerical time-integration methods. To do this the time interval \\([t_0,t_\\text{end}]\\) is discretized into a finite number of time points \\(t_0 &lt; t_1 &lt; \\ldots &lt; t_N = t_\\text{end}\\) for which approximate solutions \\(\\mathbf{w}_n \\approx \\mathbf{u}(t_n)\\) are computed. In general we do not assume a fixed timestep (the interval between successive points in time). Rather, the solver attempts to make as large a step as possible while keeping error tolerances within requirements. The solver settings section details the available configuration options.",
    "crumbs": [
      "Julia core",
      "Numerical considerations"
    ]
  },
  {
    "objectID": "core/numerics.html#euler-forward",
    "href": "core/numerics.html#euler-forward",
    "title": "Numerical considerations",
    "section": "1.1 Euler forward",
    "text": "1.1 Euler forward\nThe simplest numerical method is Euler forward: \\[\n\\mathbf{w}_{n+1} = \\mathbf{w}_n + (t_{n+1}-t_n)\\mathbf{f}(\\mathbf{w}_n, t_n).\n\\tag{2}\\]\nHere \\(\\mathbf{w}_{n+1}\\) is given as a simple explicit function of \\(\\mathbf{w}_n\\).",
    "crumbs": [
      "Julia core",
      "Numerical considerations"
    ]
  },
  {
    "objectID": "core/numerics.html#euler-backward",
    "href": "core/numerics.html#euler-backward",
    "title": "Numerical considerations",
    "section": "1.2 Euler backward",
    "text": "1.2 Euler backward\nEuler backward is formulated as follows: \\[\n\\mathbf{w}_{n+1} = \\mathbf{w}_n + (t_{n+1}-t_n)\\mathbf{f}(\\mathbf{w}_{n+1},t_{n+1}).\n\\tag{3}\\]\nNote that this is an implicit equation for \\(\\mathbf{w}_{n+1}\\), which is non-linear because of the non-linearity of \\(\\mathbf{f}\\).\nGenerally one of the following iterative methods is used for finding solutions to non-linear equations like this:\n\nPicard iteration for fixed points. This method aims to approximate \\(\\mathbf{w}_{n+1}\\) as a fixed point of the function \\[\n\\mathbf{g}(\\mathbf{x}) = \\mathbf{w}_n + (t_{n+1}-t_n)\\mathbf{f}(\\mathbf{x},t_{n+1})\n\\] by iterating \\(\\mathbf{g}\\) on an initial guess of \\(\\mathbf{w}_{n+1}\\);\nNewton iterations: approximate \\(\\mathbf{w}_{n+1}\\) as a root of the function \\[\n\\mathbf{h}(\\mathbf{x}) = \\mathbf{w}_n + (t_{n+1}-t_n)\\mathbf{f}(\\mathbf{x},t_{n+1}) - \\mathbf{x},\n\\] by iteratively finding the root of its linearized form:\n\n\\[\\begin{align}\n\\mathbf{0} =& \\mathbf{h}(\\mathbf{w}_{n+1}^k) + \\mathbf{J}(\\mathbf{h})(\\mathbf{w}_{n+1}^k)(\\mathbf{w}_{n+1}^{k+1}-\\mathbf{w}_{n+1}^k) \\\\\n=& \\mathbf{w}_n + (t_{n+1}-t_n)\\mathbf{f}(\\mathbf{w}_{n+1}^k,t_{n+1}) - \\mathbf{w}_{n+1}^k \\\\ +&\\left[(t_{n+1}-t_n)\\mathbf{J}(\\mathbf{f})(\\mathbf{w}_{n+1}^k)-\\mathbf{I}\\right](\\mathbf{w}_{n+1}^{k+1}-\\mathbf{w}_{n+1}^k).\n\\end{align}\\] Note that this thus requires an evaluation of the Jacobian of \\(\\mathbf{f}\\) and solving a linear system per iteration.",
    "crumbs": [
      "Julia core",
      "Numerical considerations"
    ]
  },
  {
    "objectID": "core/numerics.html#basin-profiles",
    "href": "core/numerics.html#basin-profiles",
    "title": "Numerical considerations",
    "section": "4.1 Basin profiles",
    "text": "4.1 Basin profiles\nThe basin profiles affect \\(\\mathbf{f}\\) in many ways, anywhere where a basin level or area is required.\n\n\n\n\n\n\nNote\n\n\n\nThis section needs to be updated and extended after once this issue is resolved.",
    "crumbs": [
      "Julia core",
      "Numerical considerations"
    ]
  },
  {
    "objectID": "core/numerics.html#qh-relations",
    "href": "core/numerics.html#qh-relations",
    "title": "Numerical considerations",
    "section": "4.2 Q(h) relations",
    "text": "4.2 Q(h) relations\nTabulatedRatingCurve nodes contribute to \\(\\mathbf{f}\\) with terms of the following form:\n\\[\n    Q(h(u))\n\\]\nwhere the continuity of this term is given by the least continuous of \\(Q\\) and \\(h\\).",
    "crumbs": [
      "Julia core",
      "Numerical considerations"
    ]
  },
  {
    "objectID": "core/numerics.html#empty-basins",
    "href": "core/numerics.html#empty-basins",
    "title": "Numerical considerations",
    "section": "4.3 Empty basins",
    "text": "4.3 Empty basins\nReduction factors are introduced at several points in the definition of \\(\\mathbf{f}\\) to smooth out otherwise discontinuous transitions (e.g. the flow rate of a pump going to zero when the source basin dries out). If flows are not too large with respect to basin storage, this will prevent basins from reaching 0. Rather, the basin gets a very small storage. The reduction factors help with performance, but are also an important tool to avoid getting negative storage in basins. Negative storage needs to be avoided since it is not a real solution, and would introduce water into the model that doesn’t exist. Another tool used to avoid negative storage is the isoutoutofdomain option, which Ribasim makes use of. This rejects timesteps that lead to negative storage, instead retrying with a smaller timestep.",
    "crumbs": [
      "Julia core",
      "Numerical considerations"
    ]
  },
  {
    "objectID": "core/allocation.html",
    "href": "core/allocation.html",
    "title": "Allocation",
    "section": "",
    "text": "Allocation is the process of assigning an allocated flow rate to demand nodes in the physical layer of the model based on information about sources, the different demand nodes over various priorities, constraints introduced by nodes, local water availability and graph topology. The allocation procedure implemented in Ribasim is heavily inspired by the maximum flow problem.\nThe allocation problem is solved per subnetwork (and main network) of the Ribasim model. Each subnetwork is used to formulate an optimization problem with the JuMP package, which is solved using the HiGHS solver. For more in-depth information see also the example of solving the maximum flow problem with JuMP.jl here.\n\n\n\n\n\n\nNote\n\n\n\nwithin this Allocation section the main network is also considered to be a subnetwork.",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  },
  {
    "objectID": "core/allocation.html#schematisation-input",
    "href": "core/allocation.html#schematisation-input",
    "title": "Allocation",
    "section": "3.1 Schematisation input",
    "text": "3.1 Schematisation input\n\n3.1.1 The subnetwork\nThe allocation problem is solved per subnetwork, which is given by a subset \\(S \\subset V\\) of node ids. Different subnetworks are disjoint from eachother.\n\n\n3.1.2 Source flows\nSources are indicated by a set of edges in the subnetwork \\[\nE_S^\\text{source} \\subset E.\n\\] That is, if \\((i,j) \\in E_S^\\text{source}\\), then the average over the last allocation interval \\(\\Delta t_{\\text{alloc}}\\) of the of the flow over this edge \\[\n    \\frac{1}{\\Delta t_{\\text{alloc}}}\\int_{t - \\Delta t_{\\text{alloc}}}^tQ_{ij}(t') dt'\n\\] is treated as a source flow in the allocation problem. These edges are either coming from a boundary/source node (e.g. a level or flow boundary) or connect the main network to a subnetwork. For the definition of \\(Q_{ij}\\) see the formal model description.\n\n\n3.1.3 User demands\nThe subnetwork contains a subset of UserDemand nodes \\(U_S \\subset S\\), who all have static or time varying demands over various priorities \\(p\\): \\[\n    d^p_i(t), \\quad i \\in U_S, p = 1,2,\\ldots, p_{\\max}.\n\\]\n\n\n\n\n\n\nNote\n\n\n\nOn this page we assume that the priorities are given by all integers from \\(1\\) to some \\(p_{\\max} \\in \\mathbb{N}\\). For the Ribasim input this is not a requirement; some of these in between priority values can be missing, only the ordering of the given priorities is taken into account.\n\n\n\n\n3.1.4 Flow demands\nThe subnetwork contains a subset of nodes \\(FD_S \\subset S\\) which have a demand of a single priority \\(p_{\\text{fd}}\\). With this we define \\[\n    d^p_i(t) =\n    \\begin{cases}\n        0 \\text{ if } p \\ne p_{\\text{fd}} \\\\\n        d^{p_{\\text{df}}} \\text{ if } p = p_{\\text{fd}}\n    \\end{cases}\n\\] for all \\(i \\in FD_S\\). Here \\(d^{p_{\\text{df}}}\\) is given by the original flow demand minus the flows trough node \\(i\\) at all priorities \\(p &lt; p_{\\text{fd}}\\).",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  },
  {
    "objectID": "core/allocation.html#simulation-physical-layer-input",
    "href": "core/allocation.html#simulation-physical-layer-input",
    "title": "Allocation",
    "section": "3.2 Simulation (physical layer) input",
    "text": "3.2 Simulation (physical layer) input\n\n3.2.1 Vertical fluxes and local storage\nApart from the source flows denoted by edges, there are other sources of water in the subnetwork, associated with the basins in the subnetwork \\(B_S = B \\cap S\\). Firstly there is the average over the last allocation interval \\(\\Delta t_{\\text{alloc}}\\) of the vertical fluxes (precipitation, evaporation, infiltration and drainage) for each basin: \\[\n    \\phi_i(t) = \\frac{1}{\\Delta t_{\\text{alloc}}}\\int_{t - \\Delta t_{\\text{alloc}}}^t \\left[Q_{P,i}(t') - Q_{E,i}(t') + Q_{\\text{drn},i}(t') - Q_{\\text{inf},i}(t') \\right] dt', \\quad \\forall i \\in B_S.\n\\]\nWe consider fluxes into the basin to be positive and out of the basin to be negative. For more information see the natural water balance terms.\nSecondly, there is either a supply or demand from the storage in the basin. Given a minimum level \\(\\ell_{\\min, i}\\) and a maximum level \\(\\ell_{\\max, i}\\) which correspond to a minimum storage \\(s_{\\min, i}\\) and maximum storage \\(s_{\\max, i}\\) respectively, we get a flow supply of \\[\n    F^{\\text{basin out}}_{\\max, i} = \\max\\left(0.0, \\frac{u_i(t)-s_{\\max,i}}{\\Delta t_{\\text{alloc}}} + \\phi_i(t)\\right)\n\\]\nand a demand of \\[\n    d^p_i = \\max\\left(0.0, \\frac{s_{\\min,i} - u_i(t)}{\\Delta t_{\\text{alloc}}} - \\phi_i(t)\\right),\n\\]\nfor all \\(i \\in B_S\\). Note that the basin demand has only a single priority, so for other priorities this demand is \\(0\\).\n\n\n3.2.2 Constraining factors\n\n3.2.2.1 Flow magnitude and direction constraints\nNodes in the Ribasim model that have a max_flow_rate, i.e. Pump, Outlet and LinearResistance, put a constraint on the flow through that node. Some nodes only allow flow in one direction, like Pump, Outlet and TabulatedRatingCurve.\n\n\n3.2.2.2 FractionalFlow and UserDemand return flows\nBoth FractionalFlow and UserDemand nodes dictate proportional relationships between flows over edges in the subnetwork. UserDemands have a return factor \\(0 \\le r_i \\le 1, i \\in U_S\\), and FractionalFlow nodes have an associated fraction \\(f_j\\) which can be updated by DiscreteControl.",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  },
  {
    "objectID": "core/allocation.html#the-subnetwork-1",
    "href": "core/allocation.html#the-subnetwork-1",
    "title": "Allocation",
    "section": "3.3 The subnetwork",
    "text": "3.3 The subnetwork\nThe subnetwork consists of a set of nodes \\(S \\subset V\\) and edges\n\\[\n    E_S = (S \\times S) \\cup E_S^\\text{source},\n\\]\ni.e. the edges that lie within the subnetwork together with the source edges (which can be partially outside the subnetwork). The nodes in \\(S\\) together with the connected nodes outside the subnetwork are called the extended subnetwork.\n\n3.3.1 Capacities\nEach edge in the subnetwork has an associated capacity. These capacities are collected in the sparse capacity matrix \\(C_S \\in \\overline{\\mathbb{R}}_{\\ge 0}^{n\\times n}\\) where \\(n\\) is the number of nodes in the extended subnetwork. An edge capacity is infinite if there is nothing in the model constraining the capacity.\nThe capacities are determined in different ways:\n\nIf an edge does not exist in the allocation network, i.e. \\((i,j) \\notin E_S\\) for certain \\(1 \\le i,j\\le n'\\), then \\((C_S)_{i,j} = 0\\);\nThe capacity of the edge \\(e \\in E_S\\) is given by the smallest max_flow_rate of the nodes along the equivalent edges in the subnetwork. If there are no nodes with a max_flow_rate, the edge capacity is infinite;\nIf the edge is a source, the capacity of the edge is given by the flow rate of that source;\nIf an edge comes from a node with a flow demand, it has infinite capacity at priorities other than this of this flow demand, and zero capacity otherwise.\n\nThere are also capacities for special edges:\n\n\\(C^{LD}_S \\in \\mathbb{R}^b_{\\ge 0}\\) where \\(b = \\# B_S\\) is the number of basins, for the flow supplied by basins based on level demand (this capacity is 0 for basins that have no level demand).\n\\(C^{FD}_S \\in \\mathbb{R}^c_{\\ge 0}\\) where \\(c = \\# FD_S\\) is the number of nodes with a flow demand, for the flow supplied by flow buffers at these nodes with a flow demand.\n\\(C^{UD}_S \\in \\mathbb{R}^f_{\\ge 0}\\) where \\(f = \\# U_S\\), for the flow supplied by the user demand outflow source whose capacity is given by return flows.",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  },
  {
    "objectID": "core/allocation.html#the-optimization-variables",
    "href": "core/allocation.html#the-optimization-variables",
    "title": "Allocation",
    "section": "4.1 The optimization variables",
    "text": "4.1 The optimization variables\nThere are several types of variable whose value has to be determined to solve the allocation problem:\n\nThe flows \\(F \\in \\mathbb{R}_{\\ge 0}^{n\\times n}\\) over the edges in the allocation network;\nThe flows \\(F^\\text{basin out}_{i}, F^\\text{basin in}_{i} \\geq 0\\) for all \\(i \\in B_S\\) supplied and consumed by the basins with a level demand respectively;\nThe flows \\(F^\\text{buffer out}_{i}, F^\\text{buffer in}_{i} \\ge 0\\) for all \\(i \\in FD_S \\cup FF_S\\) supplied and consumed by the flow buffers of nodes with a flow demand or fractional flow outneighbors.",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  },
  {
    "objectID": "core/allocation.html#the-optimization-objective",
    "href": "core/allocation.html#the-optimization-objective",
    "title": "Allocation",
    "section": "4.2 The optimization objective",
    "text": "4.2 The optimization objective\nThe goal of allocation is to get the flow to nodes with demands as close as possible to these demands. To achieve this, a sum error of terms is minimized.\n\\[\n    \\min E_{\\text{user demand}} + E_{\\text{level demand}} + E_{\\text{flow demand}}\n\\]\nThe error between the flows and user demands is denoted by \\(E_{\\text{user demand}}\\), where \\[\n    E_{\\text{user demand}} = \\sum_{(i,j)\\in E_S\\;:\\; i\\in U_S} d_j^p(t)\\left(1 - \\frac{F_{ij}}{d_j^p(t)}\\right)^2\n\\]\n\n\n\n\n\n\nNote\n\n\n\nWhen performing main network allocation, the connections to subnetworks are also interpreted as UserDemand nodes with demands determined by subnetwork demand collection.\n\n\nThis type of objective cares about the fraction of the demand allocated, and will lead to an equal fraction of all demands allocated when possible. For a discussion on this see here.\nLikewise, the error of level demands from basins is the squared relative difference between flows consumed by basins and basin demands. \\[\n    E_{\\text{level demand}} = \\sum_{i \\in B_S} d_i^p(t)\\left(1 - \\frac{F_i^\\text{basin in}}{d_i^p(t)}\\right)^2\n\\]\nLastly, the error of the flow demands is given as below. \\[\n    E_{\\text{flow demand}} = \\sum_{i \\in FD_S} d_i^p(t)\\left(1 -  \\frac{F_i^\\text{buffer in}}{d_i^p(t)}\\right)^2\n\\]",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  },
  {
    "objectID": "core/allocation.html#the-optimization-constraints",
    "href": "core/allocation.html#the-optimization-constraints",
    "title": "Allocation",
    "section": "4.3 The optimization constraints",
    "text": "4.3 The optimization constraints\nFor convenience, we use the notation\n\\[\\begin{align}\n    V^{\\text{out}}_S(i) = \\left\\{j \\in V : (i,j) \\in E_S\\right\\} \\\\\n    V^{\\text{in}}_S(j) = \\left\\{i \\in V : (i,j) \\in E_S\\right\\}\n\\end{align}\\]\nfor the set of in-neighbors and out-neighbors of a node in the network respectively.\n\nFlow conservation: For all nodes \\(k\\) that are not a source or a sink (i.e. FlowBoundary, LevelBoundary, UserDemand) we have a flow conservation constraint: \\[\n  \\sum F_{\\text{out special}} + \\sum_{j \\in V^{\\text{out}}_S(k)} F_{kj} = \\sum F_{\\text{in special}} + \\sum_{i \\in V^{\\text{in}}_S(k)} F_{ik}, \\quad \\forall k \\in B_S.\n\\tag{1}\\]\n\nIn here, we have the following special flows:\n\nIf \\(k\\) is a basin with a flow demand, there is a special outflow \\(F^{\\text{basin in}}_k\\) and a special inflow \\(F^{\\text{basin out}}_k\\);\nIf the node has a buffer (see here) there is a special outflow \\(F^{\\text{buffer in}}_k\\) and a special inflow \\(F^{\\text{buffer out}}_k\\).\n\n\n\n\n\n\n\nNote\n\n\n\nIn the above, the placement of the basin and buffer flows might seem counter-intuitive. Think of the storage or buffer as a separate node connected to the node with the demand.\n\n\n\nCapacity: the flows over the edges are bounded by the edge capacity: \\[\n  F_{ij} \\le \\left(C_S\\right)_{ij}, \\quad \\forall(i,j) \\in E_S.\n\\tag{2}\\] By the definition of \\(C_S\\) this also includes the source flows. The same holds for the basin outflows:\n\n\\[\n    F^{\\text{basin out}}_{i} \\le F^{\\text{basin out}}_{\\max, i}, \\quad \\forall i \\in B_S.\n\\]\n\n\n\n\n\n\nNote\n\n\n\nWhen performing subnetwork demand collection, these capacities are set to \\(\\infty\\) for edges which connect the main network to a subnetwork. For all other sources the capacity is set to \\(0\\), so that demand collection only uses flow from the main network inlet.\n\n\nSimilar constraints hold for the flow out of basins, flow demand buffers and user demand outflow sources: \\[\nF^\\text{basin out}_{i} \\le (C^{FD}_S)_i, \\quad \\forall i \\in B_S,\n\\]\n\\[\nF^\\text{buffer out}_{i} \\le (C^{FD}_S)_i, \\quad \\forall i \\in FD_S,\n\\]\n\\[\nF_{ij} \\le (C^{UD}_S)_i, \\quad \\forall i \\in U_S, \\quad V_S^{\\text{out}}(i) = \\{j\\}.\n\\] Here we use that each UserDemand node in the allocation network has a unique outflow edge. The user outflow source capacities are increased after each optimization solve by the return fraction: \\[\n    r_i \\cdot F_{ki}, \\quad V_S^{\\text{in}}(i) = \\{k\\}.\n\\]\n\nFractional flow: Let \\(L_S \\subset V_S\\) be the set of nodes in the max flow graph with fractional flow outneighbors, and \\(f_j\\) the flow fraction associated with fractional flow node \\(j \\in V_S\\). Then \\[\n  F_{ij} \\le f_j \\sum_{k\\in V^\\text{in}_S(i)} F_{ki} \\qquad\n  \\forall i \\in L_S, \\;\n  j \\in V_S^\\text{out}(i).\n\\tag{3}\\]\nFlow sign: Furthermore there are the non-negativity constraints for the flows and allocations, see The optimization variables.",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  },
  {
    "objectID": "core/allocation.html#example",
    "href": "core/allocation.html#example",
    "title": "Allocation",
    "section": "4.4 Example",
    "text": "4.4 Example\nThe following is an example of an optimization problem for the example shown here:\n\n\nCode\nusing Ribasim\nusing Ribasim: NodeID\nusing SQLite\nusing ComponentArrays: ComponentVector\n\ntoml_path = normpath(@__DIR__, \"../../generated_testmodels/allocation_example/ribasim.toml\")\np = Ribasim.Model(toml_path).integrator.p\nu = ComponentVector(; storage = zeros(length(p.basin.node_id)))\n\nallocation_model = p.allocation.allocation_models[1]\nt = 0.0\npriority_idx = 1\n\nRibasim.set_flow!(p.graph, NodeID(:FlowBoundary, 1), NodeID(:Basin, 2), 1.0)\nRibasim.set_objective_priority!(allocation_model, p, u, t, priority_idx)\nRibasim.set_initial_values!(allocation_model, p, u, t)\n\nprintln(p.allocation.allocation_models[1].problem)\n\n\nMin F[(Basin #5, UserDemand #6)]² + F[(Basin #2, UserDemand #3)]² + F[(Basin #12, UserDemand #13)]²\nSubject to\n F[(FractionalFlow #8, Terminal #10)] ≥ 0\n F[(UserDemand #3, Basin #2)] ≥ 0\n F[(TabulatedRatingCurve #7, FractionalFlow #9)] ≥ 0\n F[(FractionalFlow #9, Basin #12)] ≥ 0\n F[(Basin #5, TabulatedRatingCurve #7)] ≥ 0\n F[(Basin #5, UserDemand #6)] ≥ 0\n F[(Basin #2, UserDemand #3)] ≥ 0\n F[(TabulatedRatingCurve #7, FractionalFlow #8)] ≥ 0\n F[(UserDemand #13, Terminal #10)] ≥ 0\n F[(FlowBoundary #1, Basin #2)] ≥ 0\n F[(Basin #12, UserDemand #13)] ≥ 0\n F[(LinearResistance #4, Basin #5)] ≥ 0\n F[(Basin #5, LinearResistance #4)] ≥ 0\n F[(Basin #2, LinearResistance #4)] ≥ 0\n F[(LinearResistance #4, Basin #2)] ≥ 0\n F[(UserDemand #6, Basin #5)] ≥ 0\n F_flow_buffer_in[TabulatedRatingCurve #7] ≥ 0\n F_flow_buffer_out[TabulatedRatingCurve #7] ≥ 0\n source[(FlowBoundary #1, Basin #2)] : F[(FlowBoundary #1, Basin #2)] ≤ 172800\n source_user[UserDemand #3] : F[(UserDemand #3, Basin #2)] ≤ 0\n source_user[UserDemand #6] : F[(UserDemand #6, Basin #5)] ≤ 0\n source_user[UserDemand #13] : F[(UserDemand #13, Terminal #10)] ≤ 0\n fractional_flow[(TabulatedRatingCurve #7, FractionalFlow #8)] : -0.6 F[(Basin #5, TabulatedRatingCurve #7)] + F[(TabulatedRatingCurve #7, FractionalFlow #8)] ≤ 0\n fractional_flow[(TabulatedRatingCurve #7, FractionalFlow #9)] : F[(TabulatedRatingCurve #7, FractionalFlow #9)] - 0.4 F[(Basin #5, TabulatedRatingCurve #7)] ≤ 0\n flow_buffer_outflow[TabulatedRatingCurve #7] : F_flow_buffer_out[TabulatedRatingCurve #7] ≤ 0\n flow_conservation[Terminal #10] : F[(FractionalFlow #8, Terminal #10)] + F[(UserDemand #13, Terminal #10)] = 0\n flow_conservation[FractionalFlow #9] : F[(TabulatedRatingCurve #7, FractionalFlow #9)] - F[(FractionalFlow #9, Basin #12)] = 0\n flow_conservation[Basin #12] : F[(FractionalFlow #9, Basin #12)] - F[(Basin #12, UserDemand #13)] = 0\n flow_conservation[Basin #2] : F[(UserDemand #3, Basin #2)] - F[(Basin #2, UserDemand #3)] + F[(FlowBoundary #1, Basin #2)] - F[(Basin #2, LinearResistance #4)] + F[(LinearResistance #4, Basin #2)] = 0\n flow_conservation[TabulatedRatingCurve #7] : -F[(TabulatedRatingCurve #7, FractionalFlow #9)] + F[(Basin #5, TabulatedRatingCurve #7)] - F[(TabulatedRatingCurve #7, FractionalFlow #8)] - F_flow_buffer_in[TabulatedRatingCurve #7] + F_flow_buffer_out[TabulatedRatingCurve #7] = 0\n flow_conservation[FractionalFlow #8] : -F[(FractionalFlow #8, Terminal #10)] + F[(TabulatedRatingCurve #7, FractionalFlow #8)] = 0\n flow_conservation[LinearResistance #4] : -F[(LinearResistance #4, Basin #5)] + F[(Basin #5, LinearResistance #4)] + F[(Basin #2, LinearResistance #4)] - F[(LinearResistance #4, Basin #2)] = 0\n flow_conservation[Basin #5] : -F[(Basin #5, TabulatedRatingCurve #7)] - F[(Basin #5, UserDemand #6)] + F[(LinearResistance #4, Basin #5)] - F[(Basin #5, LinearResistance #4)] + F[(UserDemand #6, Basin #5)] = 0",
    "crumbs": [
      "Julia core",
      "Allocation"
    ]
  }
]